<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">WeaponsSystem</string>
      <BinaryString name="AttributesSerialize">
      </BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="IntValue" referent="1">
      <Properties>
        <string name="Name">Version</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <int64 name="Value">0</int64>
      </Properties>
    </Item>
    <Item class="RemoteEvent" referent="2">
      <Properties>
        <string name="Name">WeaponData</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="Folder" referent="3">
      <Properties>
        <string name="Name">Assets</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="ScreenGui" referent="4">
        <Properties>
          <string name="Name">WeaponsSystemGui</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <bool name="AutoLocalize">false</bool>
          <int name="DisplayOrder">10000</int>
          <bool name="Enabled">true</bool>
          <bool name="IgnoreGuiInset">true</bool>
          <bool name="ResetOnSpawn">false</bool>
          <Ref name="RootLocalizationTable">null</Ref>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <token name="ZIndexBehavior">1</token>
        </Properties>
        <Item class="Frame" referent="5">
          <Properties>
            <string name="Name">Scope</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">false</bool>
            <int name="ZIndex">5</int>
          </Properties>
          <Item class="ImageLabel" referent="6">
            <Properties>
              <string name="Name">ScopeImage</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <Content name="Image">
                <url>rbxassetid://1598134910</url>
              </Content>
              <Color3 name="ImageColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <Vector2 name="ImageRectOffset">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <Vector2 name="ImageRectSize">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <float name="ImageTransparency">0</float>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <token name="ResampleMode">0</token>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <token name="ScaleType">0</token>
              <bool name="Selectable">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>0.95</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <Rect2D name="SliceCenter">
                <min>
                  <X>0</X>
                  <Y>0</Y>
                </min>
                <max>
                  <X>0</X>
                  <Y>0</Y>
                </max>
              </Rect2D>
              <float name="SliceScale">1</float>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <UDim2 name="TileSize">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <bool name="Visible">true</bool>
              <int name="ZIndex">2</int>
            </Properties>
            <Item class="UIAspectRatioConstraint" referent="7">
              <Properties>
                <string name="Name">UIAspectRatioConstraint</string>
                <float name="AspectRatio">1</float>
                <token name="AspectType">0</token>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="DominantAxis">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="Frame" referent="8">
              <Properties>
                <string name="Name">LeftBlack</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>1</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <float name="BackgroundTransparency">0</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">0</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="Frame" referent="9">
              <Properties>
                <string name="Name">RightBlack</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <float name="BackgroundTransparency">0</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">0</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="Frame" referent="10">
              <Properties>
                <string name="Name">BottomBlack</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <float name="BackgroundTransparency">0</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">0</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>5</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="Frame" referent="11">
              <Properties>
                <string name="Name">TopBlack</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>1</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <float name="BackgroundTransparency">0</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">0</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>5</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Frame" referent="12">
          <Properties>
            <string name="Name">SmallTouchscreen</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">false</bool>
            <int name="ZIndex">10</int>
          </Properties>
          <Item class="ImageButton" referent="13">
            <Properties>
              <string name="Name">FireButton</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoButtonColor">true</bool>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <Content name="HoverImage">
                <null>
                </null>
              </Content>
              <Content name="Image">
                <url>rbxassetid://2804818047</url>
              </Content>
              <Color3 name="ImageColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <Vector2 name="ImageRectOffset">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <Vector2 name="ImageRectSize">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <float name="ImageTransparency">0</float>
              <int name="LayoutOrder">0</int>
              <bool name="Modal">false</bool>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>1</XS>
                <XO>-95</XO>
                <YS>1</YS>
                <YO>-90</YO>
              </UDim2>
              <Content name="PressedImage">
                <null>
                </null>
              </Content>
              <token name="ResampleMode">0</token>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <token name="ScaleType">0</token>
              <bool name="Selectable">true</bool>
              <bool name="Selected">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0</XS>
                <XO>72</XO>
                <YS>0</YS>
                <YO>72</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <Rect2D name="SliceCenter">
                <min>
                  <X>0</X>
                  <Y>0</Y>
                </min>
                <max>
                  <X>0</X>
                  <Y>0</Y>
                </max>
              </Rect2D>
              <float name="SliceScale">1</float>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <UDim2 name="TileSize">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <bool name="Visible">true</bool>
              <int name="ZIndex">10</int>
            </Properties>
          </Item>
          <Item class="ImageButton" referent="14">
            <Properties>
              <string name="Name">AimButton</string>
              <bool name="Active">true</bool>
              <Vector2 name="AnchorPoint">
                <X>1</X>
                <Y>0</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoButtonColor">true</bool>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <Content name="HoverImage">
                <null>
                </null>
              </Content>
              <Content name="Image">
                <url>rbxassetid://2804583948</url>
              </Content>
              <Color3 name="ImageColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <Vector2 name="ImageRectOffset">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <Vector2 name="ImageRectSize">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <float name="ImageTransparency">0</float>
              <int name="LayoutOrder">0</int>
              <bool name="Modal">false</bool>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>1</XS>
                <XO>-25</XO>
                <YS>1</YS>
                <YO>-148</YO>
              </UDim2>
              <Content name="PressedImage">
                <url>rbxassetid://2804598866</url>
              </Content>
              <token name="ResampleMode">0</token>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <token name="ScaleType">0</token>
              <bool name="Selectable">true</bool>
              <bool name="Selected">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0</XS>
                <XO>44</XO>
                <YS>0</YS>
                <YO>44</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <Rect2D name="SliceCenter">
                <min>
                  <X>0</X>
                  <Y>0</Y>
                </min>
                <max>
                  <X>0</X>
                  <Y>0</Y>
                </max>
              </Rect2D>
              <float name="SliceScale">1</float>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <UDim2 name="TileSize">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <bool name="Visible">true</bool>
              <int name="ZIndex">10</int>
            </Properties>
          </Item>
        </Item>
        <Item class="Frame" referent="15">
          <Properties>
            <string name="Name">LargeTouchscreen</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">false</bool>
            <int name="ZIndex">10</int>
          </Properties>
          <Item class="ImageButton" referent="16">
            <Properties>
              <string name="Name">FireButton</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoButtonColor">true</bool>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <Content name="HoverImage">
                <null>
                </null>
              </Content>
              <Content name="Image">
                <url>rbxassetid://2804818047</url>
              </Content>
              <Color3 name="ImageColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <Vector2 name="ImageRectOffset">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <Vector2 name="ImageRectSize">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <float name="ImageTransparency">0</float>
              <int name="LayoutOrder">0</int>
              <bool name="Modal">false</bool>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>1</XS>
                <XO>-170</XO>
                <YS>1</YS>
                <YO>-210</YO>
              </UDim2>
              <Content name="PressedImage">
                <null>
                </null>
              </Content>
              <token name="ResampleMode">0</token>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <token name="ScaleType">0</token>
              <bool name="Selectable">true</bool>
              <bool name="Selected">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0</XS>
                <XO>120</XO>
                <YS>0</YS>
                <YO>120</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <Rect2D name="SliceCenter">
                <min>
                  <X>0</X>
                  <Y>0</Y>
                </min>
                <max>
                  <X>0</X>
                  <Y>0</Y>
                </max>
              </Rect2D>
              <float name="SliceScale">1</float>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <UDim2 name="TileSize">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <bool name="Visible">true</bool>
              <int name="ZIndex">10</int>
            </Properties>
          </Item>
          <Item class="ImageButton" referent="17">
            <Properties>
              <string name="Name">AimButton</string>
              <bool name="Active">true</bool>
              <Vector2 name="AnchorPoint">
                <X>1</X>
                <Y>0</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoButtonColor">true</bool>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <Content name="HoverImage">
                <null>
                </null>
              </Content>
              <Content name="Image">
                <url>rbxassetid://2804583948</url>
              </Content>
              <Color3 name="ImageColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <Vector2 name="ImageRectOffset">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <Vector2 name="ImageRectSize">
                <X>0</X>
                <Y>0</Y>
              </Vector2>
              <float name="ImageTransparency">0</float>
              <int name="LayoutOrder">0</int>
              <bool name="Modal">false</bool>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>1</XS>
                <XO>-50</XO>
                <YS>1</YS>
                <YO>-296</YO>
              </UDim2>
              <Content name="PressedImage">
                <url>rbxassetid://2804598866</url>
              </Content>
              <token name="ResampleMode">0</token>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <token name="ScaleType">0</token>
              <bool name="Selectable">true</bool>
              <bool name="Selected">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0</XS>
                <XO>88</XO>
                <YS>0</YS>
                <YO>88</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <Rect2D name="SliceCenter">
                <min>
                  <X>0</X>
                  <Y>0</Y>
                </min>
                <max>
                  <X>0</X>
                  <Y>0</Y>
                </max>
              </Rect2D>
              <float name="SliceScale">1</float>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <UDim2 name="TileSize">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <bool name="Visible">true</bool>
              <int name="ZIndex">10</int>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="18">
          <Properties>
            <string name="Name">ScalingElements</string>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="Frame" referent="19">
            <Properties>
              <string name="Name">Crosshair</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0.048</XS>
                <XO>0</XO>
                <YS>0.048</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="ImageLabel" referent="20">
              <Properties>
                <string name="Name">Top</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxassetid://2755681329</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">0</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <token name="ScaleType">0</token>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>0.4167</XS>
                  <XO>0</XO>
                  <YS>0.417</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>0</X>
                    <Y>0</Y>
                  </min>
                  <max>
                    <X>0</X>
                    <Y>0</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="ImageLabel" referent="21">
              <Properties>
                <string name="Name">Bottom</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>1</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxassetid://2755681329</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">0</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">180</float>
                <token name="ScaleType">0</token>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>0.417</XS>
                  <XO>0</XO>
                  <YS>0.417</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>0</X>
                    <Y>0</Y>
                  </min>
                  <max>
                    <X>0</X>
                    <Y>0</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="ImageLabel" referent="22">
              <Properties>
                <string name="Name">Left</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxassetid://2755681329</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">0</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">270</float>
                <token name="ScaleType">0</token>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>0.417</XS>
                  <XO>0</XO>
                  <YS>0.417</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>0</X>
                    <Y>0</Y>
                  </min>
                  <max>
                    <X>0</X>
                    <Y>0</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="ImageLabel" referent="23">
              <Properties>
                <string name="Name">Right</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>1</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxassetid://2755681329</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">0</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">90</float>
                <token name="ScaleType">0</token>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>0.417</XS>
                  <XO>0</XO>
                  <YS>0.417</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>0</X>
                    <Y>0</Y>
                  </min>
                  <max>
                    <X>0</X>
                    <Y>0</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="UIAspectRatioConstraint" referent="24">
              <Properties>
                <string name="Name">UIAspectRatioConstraint</string>
                <float name="AspectRatio">1</float>
                <token name="AspectType">0</token>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="DominantAxis">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
          <Item class="Frame" referent="25">
            <Properties>
              <string name="Name">HitMarker</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <UDim2 name="Size">
                <XS>0.048</XS>
                <XO>0</XO>
                <YS>0.048</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="UIAspectRatioConstraint" referent="26">
              <Properties>
                <string name="Name">UIAspectRatioConstraint</string>
                <float name="AspectRatio">1</float>
                <token name="AspectType">0</token>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="DominantAxis">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ImageLabel" referent="27">
              <Properties>
                <string name="Name">HitMarkerImage</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>1</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxassetid://285779644</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">1</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">180</float>
                <token name="ScaleType">0</token>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>0</X>
                    <Y>0</Y>
                  </min>
                  <max>
                    <X>0</X>
                    <Y>0</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="28">
            <Properties>
              <string name="Name">DirectionalIndicators</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="Frame" referent="29">
              <Properties>
                <string name="Name">DamageIndicator</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">180</float>
                <bool name="Selectable">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>0.18</XS>
                  <XO>0</XO>
                  <YS>0.36</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="ImageLabel" referent="30">
                <Properties>
                  <string name="Name">DamageIndicator</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.62</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <Content name="Image">
                    <url>rbxassetid://3498623805</url>
                  </Content>
                  <Color3 name="ImageColor3">
                    <R>0.8980393</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <Vector2 name="ImageRectOffset">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <Vector2 name="ImageRectSize">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <float name="ImageTransparency">1</float>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="ResampleMode">0</token>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">90</float>
                  <token name="ScaleType">1</token>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <Rect2D name="SliceCenter">
                    <min>
                      <X>0</X>
                      <Y>0</Y>
                    </min>
                    <max>
                      <X>0</X>
                      <Y>0</Y>
                    </max>
                  </Rect2D>
                  <float name="SliceScale">1</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <UDim2 name="TileSize">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UIAspectRatioConstraint" referent="31">
                  <Properties>
                    <string name="Name">UIAspectRatioConstraint</string>
                    <float name="AspectRatio">0.272</float>
                    <token name="AspectType">0</token>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <token name="DominantAxis">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="Configuration" referent="32">
                <Properties>
                  <string name="Name">Configuration</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
                <Item class="StringValue" referent="33">
                  <Properties>
                    <string name="Name">Name</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <string name="Value">DamageIndicator</string>
                  </Properties>
                </Item>
                <Item class="NumberValue" referent="34">
                  <Properties>
                    <string name="Name">TimeBeforeFade</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <double name="Value">1.5</double>
                  </Properties>
                </Item>
                <Item class="NumberValue" referent="35">
                  <Properties>
                    <string name="Name">FadeTime</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <double name="Value">1</double>
                  </Properties>
                </Item>
                <Item class="NumberValue" referent="36">
                  <Properties>
                    <string name="Name">TransparencyBeforeFade</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <double name="Value">0.25</double>
                  </Properties>
                </Item>
                <Item class="NumberValue" referent="37">
                  <Properties>
                    <string name="Name">DistanceLevelFromCenter</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <double name="Value">6</double>
                  </Properties>
                </Item>
                <Item class="NumberValue" referent="38">
                  <Properties>
                    <string name="Name">WidthLevel</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <double name="Value">6</double>
                  </Properties>
                </Item>
              </Item>
              <Item class="UIAspectRatioConstraint" referent="39">
                <Properties>
                  <string name="Name">UIAspectRatioConstraint</string>
                  <float name="AspectRatio">1</float>
                  <token name="AspectType">0</token>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <token name="DominantAxis">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="40">
        <Properties>
          <string name="Name">Animations</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="Animation" referent="41">
          <Properties>
            <string name="Name">RifleAim</string>
            <Content name="AnimationId">
              <url>rbxassetid://3972164452</url>
            </Content>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Animation" referent="42">
          <Properties>
            <string name="Name">RifleAimDownSights</string>
            <Content name="AnimationId">
              <url>rbxassetid://3972157449</url>
            </Content>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Animation" referent="43">
          <Properties>
            <string name="Name">RifleReload</string>
            <Content name="AnimationId">
              <url>rbxassetid://3972131105</url>
            </Content>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="44">
        <Properties>
          <string name="Name">Effects</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="Folder" referent="45">
          <Properties>
            <string name="Name">Shots</string>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="Part" referent="46">
            <Properties>
              <string name="Name">Bullet</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="47">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="48">
                <Properties>
                  <string name="Name">TrailParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 0.42352942 0.32941177 0 0 1 0.7607843 0.60784316 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">false</bool>
                  <NumberRange name="Lifetime">0.25 0.5 </NumberRange>
                  <float name="LightEmission">0</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">100</float>
                  <NumberRange name="RotSpeed">-50 50 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0.07 0 1 0.07 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 2 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>30</X>
                    <Y>30</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://3852340006</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 0 0 0.26406428 0.087499976 0 0.7164179 0.41249996 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0.3</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Attachment" referent="49">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Beam" referent="50">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">47</Ref>
                <Ref name="Attachment1">49</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">0</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://3867967806</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="51">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">47</Ref>
                <Ref name="Attachment1">49</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.1</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="52">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="53">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>5</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 0 1 0 0.18968385 1 0 1 0 0.20632279 0.33333334 0.30980393 0.2901961 0 1 0.26666668 0.26666668 0.26666668 0 </ColorSequence>
                  <float name="Drag">0.5</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.1 2 </NumberRange>
                  <float name="LightEmission">0.1</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.28542915 2.0486112 0.44092098 0.46706587 3.159722 1.7487373 0.89021957 4.756944 2.937265 1 5.0347223 4.9652777 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>30</X>
                    <Y>30</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.0049875313 0 0 0.15710723 0 0 0.2543641 0.69135803 0.17901236 0.53491277 0.84567904 0.056321718 0.8478803 0.97530866 0.024691343 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">-0.001</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="Sound" referent="54">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">1</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://1489924400</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">0</float>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Part" referent="55">
            <Properties>
              <string name="Name">Grenade</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="56">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="57">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Beam" referent="58">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">56</Ref>
                <Ref name="Attachment1">57</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.79607844 0.27058825 0 0.70715475 1 0.7988842 0.28083262 0 1 1 0.9647059 0.8862745 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.88860434 0.90710384 0 0.9833547 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="59">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">56</Ref>
                <Ref name="Attachment1">57</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.16901408 0.9508197 0 0.5236876 0.76502734 0 0.7861716 0.43169403 0 0.9871959 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.1</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="60">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="Sound" referent="61">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">1</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://3963013256</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">5</float>
                </Properties>
              </Item>
            </Item>
            <Item class="SpecialMesh" referent="62">
              <Properties>
                <string name="Name">Mesh</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="LODX">2</token>
                <token name="LODY">2</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=232379763</url>
                </Content>
                <token name="MeshType">5</token>
                <Vector3 name="Offset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="Scale">
                  <X>1.5</X>
                  <Y>1.5</Y>
                  <Z>1.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="TextureId">
                  <url>http://www.roblox.com/asset/?id=232379808</url>
                </Content>
                <Vector3 name="VertexColor">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Sound" referent="63">
              <Properties>
                <string name="Name">Flying</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="EmitterSize">5</float>
                <bool name="Looped">true</bool>
                <float name="xmlRead_MaxDistance_3">10000</float>
                <bool name="PlayOnRemove">false</bool>
                <float name="PlaybackSpeed">1</float>
                <bool name="Playing">false</bool>
                <token name="RollOffMode">0</token>
                <Ref name="SoundGroup">null</Ref>
                <Content name="SoundId">
                  <url>rbxassetid://3963014042</url>
                </Content>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <double name="TimePosition">0</double>
                <float name="Volume">0.5</float>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="64">
            <Properties>
              <string name="Name">Arrow</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="65">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="66">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Beam" referent="67">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">65</Ref>
                <Ref name="Attachment1">66</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 1 1 0 1 1 0.9647059 0.8862745 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">0.5</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.05121639 0.74863386 0 0.12676057 1 0 0.19334187 0.44262296 0 0.25096032 1 0 0.35339308 0.25136614 0 0.418694 1 0 0.47119078 0.14754099 0 0.5377721 0.8579235 0 0.653009 0 0 0.71702945 1 0 0.8143406 0 0 0.89628685 1 0 0.99231756 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.25</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="68">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">65</Ref>
                <Ref name="Attachment1">66</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 1 1 0 1 0.8627451 0.8627451 0.8627451 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.08578745 0.75409836 0 0.26248398 0.55191255 0 0.6043534 0.43169403 0 0.88988477 0.43169403 0 0.99103713 0.28415304 0 1 1 0 </NumberSequence>
                <float name="Width0">0.25</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="69">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="70">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>5</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 0 1 0 0.18968385 1 0 1 0 0.20632279 0.33333334 0.30980393 0.2901961 0 1 0.26666668 0.26666668 0.26666668 0 </ColorSequence>
                  <float name="Drag">0.5</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.1 2 </NumberRange>
                  <float name="LightEmission">0.1</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.28542915 2.0486112 0.44092098 0.46706587 3.159722 1.7487373 0.89021957 4.756944 2.937265 1 5.0347223 4.9652777 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>30</X>
                    <Y>30</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.0049875313 0 0 0.15710723 0 0 0.2543641 0.69135803 0.17901236 0.53491277 0.84567904 0.056321718 0.8478803 0.97530866 0.024691343 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">-0.001</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="Sound" referent="71">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">1</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://3963012401</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">0.25</float>
                </Properties>
              </Item>
            </Item>
            <Item class="SpecialMesh" referent="72">
              <Properties>
                <string name="Name">Mesh</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="LODX">2</token>
                <token name="LODY">2</token>
                <Content name="MeshId">
                  <url>rbxassetid://2493118549</url>
                </Content>
                <token name="MeshType">5</token>
                <Vector3 name="Offset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>-0.9</Z>
                </Vector3>
                <Vector3 name="Scale">
                  <X>0.43178</X>
                  <Y>0.43178</Y>
                  <Z>0.43178</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="TextureId">
                  <url>rbxassetid://2493025364</url>
                </Content>
                <Vector3 name="VertexColor">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="73">
            <Properties>
              <string name="Name">Rocket</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="74">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="75">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="76">
                <Properties>
                  <string name="Name">LeadingParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 0.47058824 0.11764706 0 0.5024958 1 0.3529412 0.15686275 0 1 0.8156863 0.49019608 0 0 </ColorSequence>
                  <float name="Drag">5</float>
                  <token name="EmissionDirection">3</token>
                  <bool name="Enabled">false</bool>
                  <NumberRange name="Lifetime">0.1 0.25 </NumberRange>
                  <float name="LightEmission">1</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">500</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0.3125 0 0.26147705 0.3472221 0.069444776 0.6187625 0.72916687 0.20833313 0.85728544 1.5625 0 1 2.8819442 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">-5 -5 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>10</X>
                    <Y>10</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/fire_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.032418955 0.07407409 0 0.13341646 0 0 0.5473816 0 0 0.8067332 0.09876543 0 0.9663342 0.2530864 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">-0.1</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Beam" referent="77">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">74</Ref>
                <Ref name="Attachment1">75</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.79607844 0.27058825 0 0.70715475 1 0.7988842 0.28083262 0 1 1 0.9647059 0.8862745 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.88860434 0.90710384 0 0.9833547 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="78">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">74</Ref>
                <Ref name="Attachment1">75</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.16901408 0.9508197 0 0.5236876 0.76502734 0 0.7861716 0.43169403 0 0.9871959 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.1</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="79">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="80">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 0.9882353 0.92941177 0 0.023294508 0.97466004 0.9257694 0.79799765 0 0.19301164 1 0.8039216 0.09411765 0 0.39434275 1 0.7058824 0.10980392 0 1 0.19607843 0.13333334 0.011764706 0 </ColorSequence>
                  <float name="Drag">10</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.1 2 </NumberRange>
                  <float name="LightEmission">1</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.04291417 2.916667 0.13888896 0.15668663 2.3611112 0.13635153 0.46506986 5.520834 0.12476483 1 8.125 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>15</X>
                    <Y>15</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.016209478 0 0 0.2605985 0.7654321 0.14197528 0.4713217 0.97530866 0.024691343 0.8478803 0.9876543 0.012345672 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="Sound" referent="81">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">1</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://3963015379</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">5</float>
                </Properties>
              </Item>
            </Item>
            <Item class="SpecialMesh" referent="82">
              <Properties>
                <string name="Name">Mesh</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="LODX">2</token>
                <token name="LODY">2</token>
                <Content name="MeshId">
                  <url>rbxassetid://94690081</url>
                </Content>
                <token name="MeshType">5</token>
                <Vector3 name="Offset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>-2</Z>
                </Vector3>
                <Vector3 name="Scale">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="TextureId">
                  <url>rbxassetid://94689966</url>
                </Content>
                <Vector3 name="VertexColor">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Sound" referent="83">
              <Properties>
                <string name="Name">Flying</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="EmitterSize">5</float>
                <bool name="Looped">true</bool>
                <float name="xmlRead_MaxDistance_3">10000</float>
                <bool name="PlayOnRemove">false</bool>
                <float name="PlaybackSpeed">1</float>
                <bool name="Playing">false</bool>
                <token name="RollOffMode">0</token>
                <Ref name="SoundGroup">null</Ref>
                <Content name="SoundId">
                  <url>rbxassetid://3963016451</url>
                </Content>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <double name="TimePosition">0</double>
                <float name="Volume">2</float>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="84">
            <Properties>
              <string name="Name">Railgun</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="85">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="86">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Beam" referent="87">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">85</Ref>
                <Ref name="Attachment1">86</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.92156863 0.56078434 0 1 1 0.92156863 0.56078434 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1286995910</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="88">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">85</Ref>
                <Ref name="Attachment1">86</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.1</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="89">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="Sound" referent="90">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">0.25</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://1489924400</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">2</float>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="91">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>5</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 1 1 0 0.123128116 1 0.9766586 0.94356704 0 0.24292845 1 0.6901961 0.2509804 0 0.61896837 1 0.5882353 0.17254902 0 0.7271215 0.4 0.03529412 0.03529412 0 0.7836938 0.14901961 0.12156863 0.12156863 0 1 0.14901961 0.14901961 0.14901961 0 </ColorSequence>
                  <float name="Drag">0.5</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">false</bool>
                  <NumberRange name="Lifetime">0.1 1 </NumberRange>
                  <float name="LightEmission">1</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.28542915 2.0486112 0.44092098 0.46706587 3.159722 1.7487373 0.89021957 4.756944 2.937265 1 5.0347223 4.9652777 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 2 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>30</X>
                    <Y>30</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://552389687</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.0049875313 0 0 0.15710723 0 0 0.2543641 0.69135803 0.17901236 0.53491277 0.84567904 0.056321718 0.8478803 0.97530866 0.024691343 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">-0.001</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="ParticleEmitter" referent="92">
              <Properties>
                <string name="Name">MuzzleParticles</string>
                <Vector3 name="Acceleration">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 1 1 0 0.6672213 1 0.5803922 0.5803922 0 1 0.1882353 0.03529412 0.03529412 0 </ColorSequence>
                <float name="Drag">8</float>
                <token name="EmissionDirection">5</token>
                <bool name="Enabled">false</bool>
                <NumberRange name="Lifetime">0.5 1 </NumberRange>
                <float name="LightEmission">0.5</float>
                <float name="LightInfluence">0.5</float>
                <bool name="LockedToPart">false</bool>
                <token name="Orientation">0</token>
                <float name="Rate">0</float>
                <NumberRange name="RotSpeed">-100 100 </NumberRange>
                <NumberRange name="Rotation">-180 180 </NumberRange>
                <token name="Shape">0</token>
                <token name="ShapeInOut">0</token>
                <float name="ShapePartial">1</float>
                <token name="ShapeStyle">0</token>
                <NumberSequence name="Size">0 0 0 0.040918164 0.83333313 0.20833313 0.3942116 3.1944442 0.2777779 0.47205588 0.625 0 0.65868264 0.72916687 0.72916687 0.69361275 0 0 0.9750499 0.41666687 0.41666687 1 0 0 </NumberSequence>
                <int64 name="SourceAssetId">-1</int64>
                <NumberRange name="Speed">5 25 </NumberRange>
                <Vector2 name="SpreadAngle">
                  <X>30</X>
                  <Y>30</Y>
                </Vector2>
                <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://552389687</url>
                </Content>
                <float name="TimeScale">1</float>
                <NumberSequence name="Transparency">0 1 0 0.046134666 0.83950615 0.06790125 0.10723192 0.90123457 0 0.20947632 0.7037037 0.069664806 0.29426435 0.80246913 0 0.34663343 0.6728395 0.037037015 0.39276809 0.93209875 0.043850943 0.5236908 0.56172836 0.056321718 0.5685786 0.89506173 0.044521157 0.6483791 0.6851852 0.03372099 0.7755611 0.9259259 0.024691343 1 1 0 </NumberSequence>
                <float name="VelocityInheritance">0</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="93">
            <Properties>
              <string name="Name">Plasma</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="94">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="95">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="96">
                <Properties>
                  <string name="Name">LeadingParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 0.49803922 0.91764706 1 0 1 1 1 1 0 </ColorSequence>
                  <float name="Drag">0.5</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">false</bool>
                  <NumberRange name="Lifetime">0.1 0.25 </NumberRange>
                  <float name="LightEmission">1</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">true</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">100</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0.3125 0.2777779 0.03992016 0.5902779 0.5902779 0.058882236 1.3194442 0.45138884 0.11177645 0.41666687 0.20833313 0.65868264 0.20833313 0.20833313 1 0 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">5 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>180</X>
                    <Y>180</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.13341646 0 0 0.5473816 0 0 0.7705736 0.7407408 0 0.86159605 0.95679015 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Beam" referent="97">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">94</Ref>
                <Ref name="Attachment1">95</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 0.49803922 0.91764706 1 0 1 0.49803922 0.91764706 1 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.25</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="98">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">94</Ref>
                <Ref name="Attachment1">95</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://1287002748</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">0.1</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="99">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="ParticleEmitter" referent="100">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 0.60784316 0.9372549 1 0 1 0 0.39215687 0.47058824 0 </ColorSequence>
                  <float name="Drag">10</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 2 </NumberRange>
                  <float name="LightEmission">1</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.048902195 1.25 0.13888896 0.10479042 0.9722221 0.13635153 0.35828343 2.1180553 0.12476483 1 3.5069442 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>15</X>
                    <Y>15</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.016209478 0 0 0.2605985 0.7654321 0.14197528 0.4713217 0.97530866 0.024691343 0.8478803 0.9876543 0.012345672 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="Sound" referent="101">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">2</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://878000314</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">0.25</float>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Part" referent="102">
            <Properties>
              <string name="Name">CannonBall</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-11.321</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">2697776</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>true</CustomPhysics>
                <Density>13</Density>
                <Friction>0.8</Friction>
                <Elasticity>0.05</Elasticity>
                <FrictionWeight>10</FrictionWeight>
                <ElasticityWeight>100</ElasticityWeight>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">1088</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">0</token>
              <Vector3 name="size">
                <X>2</X>
                <Y>2</Y>
                <Z>2</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Attachment" referent="103">
              <Properties>
                <string name="Name">Attachment0</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Attachment" referent="104">
              <Properties>
                <string name="Name">Attachment1</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
            </Item>
            <Item class="Beam" referent="105">
              <Properties>
                <string name="Name">Beam0</string>
                <Ref name="Attachment0">103</Ref>
                <Ref name="Attachment1">104</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 0.6392157 0.6392157 0.6392157 0 1 0.34901962 0.34901962 0.34901962 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">1</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">2</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Beam" referent="106">
              <Properties>
                <string name="Name">Beam1</string>
                <Ref name="Attachment0">103</Ref>
                <Ref name="Attachment1">104</Ref>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="Brightness">1</float>
                <ColorSequence name="Color">0 1 0.9664454 0.82661176 0 1 0.9773098 0.951751 0.7822232 0 </ColorSequence>
                <float name="CurveSize0">0</float>
                <float name="CurveSize1">0</float>
                <bool name="Enabled">false</bool>
                <bool name="FaceCamera">true</bool>
                <float name="LightEmission">1</float>
                <float name="LightInfluence">0</float>
                <int name="Segments">50</int>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://2463944225</url>
                </Content>
                <float name="TextureLength">1</float>
                <token name="TextureMode">0</token>
                <float name="TextureSpeed">0</float>
                <NumberSequence name="Transparency">0 1 0 0.02 0 0 0.98 0 0 1 1 0 </NumberSequence>
                <float name="Width0">0.1</float>
                <float name="Width1">3</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
            <Item class="Attachment" referent="107">
              <Properties>
                <string name="Name">HitEffect</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">false</bool>
              </Properties>
              <Item class="Sound" referent="108">
                <Properties>
                  <string name="Name">HitSound</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="EmitterSize">10</float>
                  <bool name="Looped">false</bool>
                  <float name="xmlRead_MaxDistance_3">10000</float>
                  <bool name="PlayOnRemove">false</bool>
                  <float name="PlaybackSpeed">1</float>
                  <bool name="Playing">false</bool>
                  <token name="RollOffMode">0</token>
                  <Ref name="SoundGroup">null</Ref>
                  <Content name="SoundId">
                    <url>rbxassetid://1489924400</url>
                  </Content>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <double name="TimePosition">0</double>
                  <float name="Volume">0.25</float>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="109">
                <Properties>
                  <string name="Name">HitParticles</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>5</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="Brightness">1</float>
                  <ColorSequence name="Color">0 1 0 1 0 0.18968385 1 0 1 0 0.20632279 0.33333334 0.30980393 0.2901961 0 1 0.26666668 0.26666668 0.26666668 0 </ColorSequence>
                  <float name="Drag">0.5</float>
                  <token name="EmissionDirection">5</token>
                  <bool name="Enabled">false</bool>
                  <NumberRange name="Lifetime">0.1 2 </NumberRange>
                  <float name="LightEmission">0.1</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <token name="Orientation">0</token>
                  <float name="Rate">0</float>
                  <NumberRange name="RotSpeed">-100 100 </NumberRange>
                  <NumberRange name="Rotation">-180 180 </NumberRange>
                  <token name="Shape">0</token>
                  <token name="ShapeInOut">0</token>
                  <float name="ShapePartial">1</float>
                  <token name="ShapeStyle">0</token>
                  <NumberSequence name="Size">0 0 0 0.28542915 2.0486112 0.44092098 0.46706587 3.159722 1.7487373 0.89021957 4.756944 2.937265 1 5.0347223 4.9652777 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 10 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>30</X>
                    <Y>30</Y>
                  </Vector2>
                  <NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
                  <BinaryString name="Tags"></BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/smoke_main.dds</url>
                  </Content>
                  <float name="TimeScale">1</float>
                  <NumberSequence name="Transparency">0 1 0 0.0049875313 0 0 0.15710723 0 0 0.2543641 0.69135803 0.17901236 0.53491277 0.84567904 0.056321718 0.8478803 0.97530866 0.024691343 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">-0.001</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="110">
          <Properties>
            <string name="Name">HitMarks</string>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="Part" referent="111">
            <Properties>
              <string name="Name">BulletHole</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">false</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.5</X>
                <Y>0.5</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="BillboardGui" referent="112">
              <Properties>
                <string name="Name">ImpactBillboard</string>
                <bool name="Active">false</bool>
                <Ref name="Adornee">111</Ref>
                <bool name="AlwaysOnTop">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoLocalize">true</bool>
                <float name="Brightness">1</float>
                <bool name="ClipsDescendants">false</bool>
                <float name="DistanceLowerLimit">0</float>
                <float name="DistanceStep">0</float>
                <float name="DistanceUpperLimit">-1</float>
                <bool name="Enabled">true</bool>
                <Vector3 name="ExtentsOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0.25</Z>
                </Vector3>
                <Vector3 name="ExtentsOffsetWorldSpace">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <float name="LightInfluence">1</float>
                <float name="MaxDistance">INF</float>
                <Ref name="PlayerToHideFrom">null</Ref>
                <bool name="ResetOnSpawn">false</bool>
                <Ref name="RootLocalizationTable">null</Ref>
                <UDim2 name="Size">
                  <XS>5</XS>
                  <XO>0</XO>
                  <YS>5</YS>
                  <YO>0</YO>
                </UDim2>
                <Vector2 name="SizeOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <int64 name="SourceAssetId">-1</int64>
                <Vector3 name="StudsOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="StudsOffsetWorldSpace">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="Tags"></BinaryString>
                <token name="ZIndexBehavior">1</token>
              </Properties>
              <Item class="ImageLabel" referent="113">
                <Properties>
                  <string name="Name">Impact</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">0</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <Content name="Image">
                    <url>rbxassetid://3918596245</url>
                  </Content>
                  <Color3 name="ImageColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <Vector2 name="ImageRectOffset">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <Vector2 name="ImageRectSize">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <float name="ImageTransparency">1</float>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="ResampleMode">0</token>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <token name="ScaleType">0</token>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <Rect2D name="SliceCenter">
                    <min>
                      <X>0</X>
                      <Y>0</Y>
                    </min>
                    <max>
                      <X>0</X>
                      <Y>0</Y>
                    </max>
                  </Rect2D>
                  <float name="SliceScale">1</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                  <UDim2 name="TileSize">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
              </Item>
            </Item>
            <Item class="Decal" referent="114">
              <Properties>
                <string name="Name">BulletHole</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>0.8313726</G>
                  <B>0.43529415</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=2078626</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="115">
            <Properties>
              <string name="Name">Pellet</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.2</X>
                <Y>0.2</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Decal" referent="116">
              <Properties>
                <string name="Name">BulletHole</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>0.8313726</G>
                  <B>0.43529415</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=2078626</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="117">
            <Properties>
              <string name="Name">Arrow</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.05</X>
                <Y>0.05</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="SpecialMesh" referent="118">
              <Properties>
                <string name="Name">Mesh</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="LODX">2</token>
                <token name="LODY">2</token>
                <Content name="MeshId">
                  <url>rbxassetid://2493118549</url>
                </Content>
                <token name="MeshType">5</token>
                <Vector3 name="Offset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0.75</Z>
                </Vector3>
                <Vector3 name="Scale">
                  <X>0.43178</X>
                  <Y>0.43178</Y>
                  <Z>0.43178</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="TextureId">
                  <url>rbxassetid://2493025364</url>
                </Content>
                <Vector3 name="VertexColor">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="119">
            <Properties>
              <string name="Name">Scorch</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-11.321</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>2</X>
                <Y>2</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Decal" referent="120">
              <Properties>
                <string name="Name">ScorchMark</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://53875997</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="Decal" referent="121">
              <Properties>
                <string name="Name">Glow</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>0.25882354</G>
                  <B>0.1137255</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=246689799</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="122">
            <Properties>
              <string name="Name">Explosion</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-11.321</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>2.5</X>
                <Y>2.5</Y>
                <Z>0.05</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Decal" referent="123">
              <Properties>
                <string name="Name">ScorchMark</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>rbxassetid://53875997</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="Decal" referent="124">
              <Properties>
                <string name="Name">Glow</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <Color3 name="Color3">
                  <R>1</R>
                  <G>0.25882354</G>
                  <B>0.1137255</B>
                </Color3>
                <token name="Face">2</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=246689799</url>
                </Content>
                <float name="Transparency">1</float>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="125">
          <Properties>
            <string name="Name">Casings</string>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="MeshPart" referent="126">
            <Properties>
              <string name="Name">RifleCasing</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>0</R00>
                <R01>1</R01>
                <R02>0</R02>
                <R10>-1</R10>
                <R11>0</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16756736</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <bool name="DoubleSided">false</bool>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <bool name="HasJointOffset">false</bool>
              <bool name="HasSkinnedMesh">false</bool>
              <Vector3 name="InitialSize">
                <X>2.0782347</X>
                <Y>6.515327</Y>
                <Z>2.078235</Z>
              </Vector3>
              <Vector3 name="JointOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <BinaryString name="LODData">
              </BinaryString>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">1088</token>
              <Content name="MeshID">
                <url>rbxassetid://2794280533</url>
              </Content>
              <Content name="MeshId">
                <url>rbxassetid://2794280533</url>
              </Content>
              <SharedString name="PhysicalConfigData">jMO+3ujG8WZbCV+FbCLE5Q==</SharedString>
              <BinaryString name="PhysicsData">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <token name="RenderFidelity">1</token>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Vector3 name="size">
                <X>0.106</X>
                <Y>0.33</Y>
                <Z>0.106</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <Content name="TextureID">
                <url>rbxassetid://2794275376</url>
              </Content>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Sound" referent="127">
              <Properties>
                <string name="Name">CasingHitSound</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="EmitterSize">1</float>
                <bool name="Looped">false</bool>
                <float name="xmlRead_MaxDistance_3">10000</float>
                <bool name="PlayOnRemove">false</bool>
                <float name="PlaybackSpeed">1</float>
                <bool name="Playing">false</bool>
                <token name="RollOffMode">0</token>
                <Ref name="SoundGroup">null</Ref>
                <Content name="SoundId">
                  <url>rbxassetid://3909012115</url>
                </Content>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <double name="TimePosition">0</double>
                <float name="Volume">1</float>
              </Properties>
            </Item>
          </Item>
          <Item class="MeshPart" referent="128">
            <Properties>
              <string name="Name">PistolCasing</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-10.572</X>
                <Y>9.708</Y>
                <Z>-105.981</Z>
                <R00>0</R00>
                <R01>1</R01>
                <R02>0</R02>
                <R10>-1</R10>
                <R11>0</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16756736</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <bool name="DoubleSided">false</bool>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <bool name="HasJointOffset">false</bool>
              <bool name="HasSkinnedMesh">false</bool>
              <Vector3 name="InitialSize">
                <X>2.0782347</X>
                <Y>2.668536</Y>
                <Z>2.078235</Z>
              </Vector3>
              <Vector3 name="JointOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <BinaryString name="LODData">
              </BinaryString>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">1088</token>
              <Content name="MeshID">
                <url>rbxassetid://2794279992</url>
              </Content>
              <Content name="MeshId">
                <url>rbxassetid://2794279992</url>
              </Content>
              <SharedString name="PhysicalConfigData">jMO+3ujG8WZbCV+FbCLE5Q==</SharedString>
              <BinaryString name="PhysicsData">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <token name="RenderFidelity">1</token>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Vector3 name="size">
                <X>0.083</X>
                <Y>0.107</Y>
                <Z>0.083</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <Content name="TextureID">
                <url>rbxassetid://2794275376</url>
              </Content>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="Sound" referent="129">
              <Properties>
                <string name="Name">CasingHitSound</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="EmitterSize">1</float>
                <bool name="Looped">false</bool>
                <float name="xmlRead_MaxDistance_3">10000</float>
                <bool name="PlayOnRemove">false</bool>
                <float name="PlaybackSpeed">1</float>
                <bool name="Playing">false</bool>
                <token name="RollOffMode">0</token>
                <Ref name="SoundGroup">null</Ref>
                <Content name="SoundId">
                  <url>rbxassetid://3909012115</url>
                </Content>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <double name="TimePosition">0</double>
                <float name="Volume">1</float>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="130">
      <Properties>
        <string name="Name">NetworkingCallbacks</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <Content name="LinkedSource">
          <null>
          </null>
        </Content>
        <BinaryString name="ScriptGuid"><![CDATA[e0VBRTYyNkQ2LThCNkYtNDE3OS1BMTA4LTEyM0RCMTFGNTY4QX0=]]></BinaryString>
        <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()
local LocalPlayer = (not IsServer) and Players.LocalPlayer or nil

local NetworkingCallbacks = {}
NetworkingCallbacks.WeaponsSystem = nil

function NetworkingCallbacks.WeaponFired(player, instance, fireInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weaponType.CanBeFired and weapon.player == player then
			weapon:onFired(player, fireInfo, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadRequest(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded then
			weapon:reload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloaded(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= nil and player ~= LocalPlayer then
			weapon:onReloaded(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadCanceled(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= LocalPlayer then
			weapon:cancelReload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponHit(player, instance, hitInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanHit then
			if IsServer then
				weapon:onHit(hitInfo)
			end
		end
	end
end

function NetworkingCallbacks.WeaponActivated(player, instance, activated)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weapon.player == player then
			weapon:setActivated(activated, true)
		end
	end
end

return NetworkingCallbacks
]]></string>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="Folder" referent="131">
      <Properties>
        <string name="Name">WeaponTypes</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="ModuleScript" referent="132">
        <Properties>
          <string name="Name">BowWeapon</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezI3RUZEMTVFLUZENDMtNEE5Ni1BQUE3LTFENTA4MTkyMDBGMH0=]]></BinaryString>
          <string name="Source">local RunService = game:GetService("RunService")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent

local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local BulletWeapon = require(WeaponTypes:WaitForChild("BulletWeapon"))

local BowWeapon = {}
BowWeapon.__index = BowWeapon
setmetatable(BowWeapon, BulletWeapon)

BowWeapon.CanAimDownSights = true
BowWeapon.CanBeFired = true
BowWeapon.CanBeReloaded = true
BowWeapon.CanHit = true

function BowWeapon.new(weaponsSystem, instance)
	local self = BulletWeapon.new(weaponsSystem, instance)
	setmetatable(self, BowWeapon)

	self.hasArrow = true

	self.arrowPart = self.instance:FindFirstChild("Arrow", true)
	self.armsPart = self.instance:FindFirstChild("Arms", true)
	if self.armsPart then
		self.armsMesh = self.armsPart:FindFirstChildOfClass("SpecialMesh")

		self.tightOffsetValue = self.armsPart:FindFirstChild("TightOffset")
		self.tightScaleValue = self.armsPart:FindFirstChild("TightScale")

		self.looseOffsetValue = self.armsPart:FindFirstChild("LooseOffset")
		self.looseScaleValue = self.armsPart:FindFirstChild("LooseScale")

		self.leftLooseAttach = self.armsPart:FindFirstChild("LeftLoose")
		self.rightLooseAttach = self.armsPart:FindFirstChild("RightLoose")

		self.leftTightAttach = self.armsPart:FindFirstChild("LeftTight")
		self.rightTightAttach = self.armsPart:FindFirstChild("RightTight")

		self.leftString0 = self.armsPart:FindFirstChild("LeftString0")
		self.rightString0 = self.armsPart:FindFirstChild("RightString0")
	end

	self.string1 = self.instance:FindFirstChild("String1", true)
	self.stringLooseAttach = self.instance:FindFirstChild("StringLoose", true)
	self.stringTightAttach = self.instance:FindFirstChild("StringTight", true)

	self:setHasArrow(false)

	return self
end

function BowWeapon:renderCharge()
	if self.armsMesh and self.looseOffsetValue and self.looseScaleValue and self.tightOffsetValue and self.tightScaleValue then
		local looseOffset, tightOffset = self.looseOffsetValue.Value, self.tightOffsetValue.Value
		local looseScale, tightScale = self.looseScaleValue.Value, self.tightScaleValue.Value

		self.armsMesh.Offset = looseOffset:Lerp(tightOffset, self.charge)
		self.armsMesh.Scale = looseScale:Lerp(tightScale, self.charge)
	end

	if self.leftString0 and self.leftLooseAttach and self.leftTightAttach then
		self.leftString0.CFrame = self.leftLooseAttach.CFrame:lerp(self.leftTightAttach.CFrame, self.charge)
	end
	if self.rightString0 and self.rightLooseAttach and self.rightTightAttach then
		self.rightString0.CFrame = self.rightLooseAttach.CFrame:lerp(self.rightTightAttach.CFrame, self.charge)
	end

	if self.string1 and self.stringLooseAttach and self.stringTightAttach then
		self.string1.CFrame = self.stringLooseAttach.CFrame:lerp(self.stringTightAttach.CFrame, self.charge)
	end
end

function BowWeapon:handleCharging(dt)
	if self.hasArrow then return end
	BulletWeapon.handleCharging(self, dt)

	if self.charge >= 1 then
		self:setHasArrow(true)
	end
end

function BowWeapon:onActivatedChanged()
	if not IsServer then
		if not self.activated then
			if self.didFire then
				self.didFire = false
			end
		end
	end
	BulletWeapon.onActivatedChanged(self)
end

function BowWeapon:isCharged()
	return self.hasArrow and self.charge >= 1
end

function BowWeapon:doLocalFire()
	BulletWeapon.doLocalFire(self)
	self:setHasArrow(false)
	self.didFire = true
end

function BowWeapon:setHasArrow(hasArrow)
	if self.hasArrow == hasArrow then
		return
	end

	self.hasArrow = hasArrow
	if self.arrowPart then
		self.arrowPart.Transparency = self.hasArrow and 0 or 1
	end
end

return BowWeapon</string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="133">
        <Properties>
          <string name="Name">BulletWeapon</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezRCRjM2RDJBLUI4NkYtNEE3Qy04RDg2LTg3N0M1MTQwODJGQ30=]]></BinaryString>
          <string name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local ContentProvider = game:GetService("ContentProvider")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local BaseWeapon = require(Libraries:WaitForChild("BaseWeapon"))
local Parabola = require(Libraries:WaitForChild("Parabola"))
local Roblox = require(Libraries:WaitForChild("Roblox"))

local Effects = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Effects")
local ShotsFolder = Effects:WaitForChild("Shots")
local HitMarksFolder = Effects:WaitForChild("HitMarks")
local CasingsFolder = Effects:WaitForChild("Casings")

local NO_BULLET_DECALS = false
local NO_BULLET_CASINGS = false

--The ignore list will fill up over time. This is how many seconds it will go before
--being refreshed in order to keep it from filling up with instances that aren't in
--the datamodel anymore.
local IGNORE_LIST_LIFETIME = 5

local MAX_BULLET_TIME = 10

local localRandom = Random.new()
local localPlayer = not IsServer and Players.LocalPlayer

local BulletWeapon = {}
BulletWeapon.__index = BulletWeapon
setmetatable(BulletWeapon, BaseWeapon)

BulletWeapon.CanAimDownSights = true
BulletWeapon.CanBeFired = true
BulletWeapon.CanBeReloaded = true
BulletWeapon.CanHit = true

function BulletWeapon.new(weaponsSystem, instance)
	local self = BaseWeapon.new(weaponsSystem, instance)
	setmetatable(self, BulletWeapon)

	self.usesCharging = false
	self.charge = 0
	self.chargeSoundPitchMin = 0.5
	self.chargeSoundPitchMax = 1

	self.triggerDisconnected = false
	self.startupFinished = false -- TODO: make startup time use a configuration value
	self.burstFiring = false
	self.burstIdx = 0
	self.nextFireTime = 0

	self.recoilIntensity = 0
	self.aimPoint = Vector3.new()

	self:addOptionalDescendant("tipAttach", "TipAttachment")

	self:addOptionalDescendant("boltMotor", "BoltMotor")
	self:addOptionalDescendant("boltMotorStart", "BoltMotorStart")
	self:addOptionalDescendant("boltMotorTarget", "BoltMotorTarget")

	self:addOptionalDescendant("chargeGlowPart", "ChargeGlow")
	self:addOptionalDescendant("chargeCompleteParticles", "ChargeCompleteParticles")
	self:addOptionalDescendant("dischargeCompleteParticles", "DischargeCompleteParticles")

	self:addOptionalDescendant("muzzleFlash0", "MuzzleFlash0")
	self:addOptionalDescendant("muzzleFlash1", "MuzzleFlash1")
	self:addOptionalDescendant("muzzleFlashBeam", "MuzzleFlash")

	self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))

	self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
	self:addOptionalDescendant("casingEjectPoint", "CasingEjectPoint")

	self.ignoreList = {}
	self.ignoreListRefreshTime = 0

	self:addOptionalDescendant("handAttach", "LeftHandAttachment")
	self.handAlignPos = nil
	self.handAlignRot = nil

	self.chargingParticles = {}
	self.instance.DescendantAdded:Connect(function(descendant)
		if descendant.Name == "ChargingParticles" and descendant:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, descendant)
		end
	end)
	for _, v in pairs(self.instance:GetDescendants()) do
		if v.Name == "ChargingParticles" and v:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, v)
		end
	end

	self:doInitialSetup()

	return self
end

function BulletWeapon:onEquippedChanged()
	BaseWeapon.onEquippedChanged(self)

	if not IsServer then
		if self.weaponsSystem.camera then
			if self.equipped then
				self.startupFinished = false
			end
		end

		if self.equipped then
			ContextActionService:BindAction("ReloadWeapon", function(...) self:onReloadAction(...) end, false, Enum.KeyCode.R, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("ReloadWeapon")

			-- Stop charging/discharging sounds
			local chargingSound = self:getSound("Charging")
			local dischargingSound = self:getSound("Discharging")
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
		end

		self.triggerDisconnected = false
	end
end

function BulletWeapon:onReloadAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin and not self.reloading then
		self:reload()
	end
end

function BulletWeapon:animateBoltAction(isOpen)
	if not self.boltMotor or not self.boltMotorStart or not self.boltMotorTarget then
		return
	end

	if isOpen then
		self:tryPlaySound("BoltOpenSound")
	else
		self:tryPlaySound("BoltCloseSound")
	end

	local actionMoveTime = isOpen and self:getConfigValue("ActionOpenTime", 0.025) or self:getConfigValue("ActionCloseTime", 0.075)
	local targetCFrame = isOpen and self.boltMotorTarget.CFrame or self.boltMotorStart.CFrame

	local boltTween = TweenService:Create(self.boltMotor, TweenInfo.new(actionMoveTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { C0 = targetCFrame })
	boltTween:Play()
	boltTween.Completed:Wait()
end

function BulletWeapon:getRandomSeedForId(id)
	return id
end

-- This function is only called on clients
function BulletWeapon:simulateFire(firingPlayer, fireInfo)
	BaseWeapon.simulateFire(self, fireInfo)

	-- Play "Fired" sound
	if self.lastFireSound then
		self.lastFireSound:Stop()
	end
	self.lastFireSound = self:tryPlaySound("Fired", self:getConfigValue("FiredPlaybackSpeedRange", 0.1))

	-- Simulate each projectile/bullet fired from current weapon
	local numProjectiles = self:getConfigValue("NumProjectiles", 1)
	local randomGenerator = Random.new(self:getRandomSeedForId(fireInfo.id))
	for i = 1, numProjectiles do
		self:simulateProjectile(firingPlayer, fireInfo, i, randomGenerator)
	end

	-- Animate the bolt if the current gun has one
	local actionOpenTime = self:getConfigValue("ActionOpenTime", 0.025)
	if self.boltMotor then
		coroutine.wrap(function()
			self:animateBoltAction(true)
			wait(actionOpenTime)
			self:animateBoltAction(false)
		end)()
	end

	-- Eject bullet casings and play "CasingHitSound" (child of casing) sound if applicable for current weapon
	if not NO_BULLET_CASINGS and self.casingTemplate and self.casingEjectPoint then
		local casing = self.casingTemplate:Clone()
		casing.Anchored = false
		casing.Archivable = false
		casing.CFrame = self.casingEjectPoint.WorldCFrame
		casing.Velocity = self.casingEjectPoint.Parent.Velocity + (self.casingEjectPoint.WorldAxis * localRandom:NextNumber(self:getConfigValue("CasingEjectSpeedMin", 15), self:getConfigValue("CasingEjectSpeedMax", 18)))
		casing.Parent = workspace.CurrentCamera
		CollectionService:AddTag(casing, "WeaponsSystemIgnore")

		local casingHitSound = casing:FindFirstChild("CasingHitSound")
		if casingHitSound then
			local touchedConn = nil
			touchedConn = casing.Touched:Connect(function(hitPart)
				if not hitPart:IsDescendantOf(self.instance) then
					casingHitSound:Play()
					touchedConn:Disconnect()
					touchedConn = nil
				end
			end)
		end

		Debris:AddItem(casing, 2)
	end

	if self.player == Players.LocalPlayer then
		coroutine.wrap(function()
			-- Wait for "RecoilDelayTime" before adding recoil
			local startTime = tick()
			local recoilDelayTime = self:getConfigValue("RecoilDelayTime", 0.07)
			while tick() < startTime + recoilDelayTime do
				RunService.RenderStepped:Wait()
			end
			RunService.RenderStepped:Wait()

			-- Add recoil to camera
			local recoilMin, recoilMax = self:getConfigValue("RecoilMin", 0.05), self:getConfigValue("RecoilMax", 0.5)
			local intensityToAdd = randomGenerator:NextNumber(recoilMin, recoilMax)
			local xIntensity = math.sin(tick() * 2) * intensityToAdd * math.rad(0.05)
			local yIntensity = intensityToAdd * 0.025
			self.weaponsSystem.camera:addRecoil(Vector2.new(xIntensity, yIntensity))

			if not (self.weaponsSystem.camera:isZoomed() and self:getConfigValue("HasScope", false)) then
				self.recoilIntensity = math.clamp(self.recoilIntensity * 1 + (intensityToAdd / 10), 0.005, 1)
			end

			-- Make crosshair reflect recoil/spread amount
			local weaponsGui = self.weaponsSystem.gui
			if weaponsGui then
				weaponsGui:setCrosshairScale(1 + intensityToAdd)
			end
		end)()
	end
end

function BulletWeapon:getIgnoreList(includeLocalPlayer)
	local now = tick()
	local ignoreList = self.ignoreList
	if not ignoreList or now - self.ignoreListRefreshTime > IGNORE_LIST_LIFETIME then
		ignoreList = {
			self.instanceIsTool and self.instance.Parent or self.instance,
			workspace.CurrentCamera
		}
		if not RunService:IsServer() then
			if includeLocalPlayer and Players.LocalPlayer and Players.LocalPlayer.Character then
				table.insert(ignoreList, Players.LocalPlayer.Character)
			end
		end
		self.ignoreList = ignoreList
	end
	return ignoreList
end

-- This function is only called on clients
function BulletWeapon:simulateProjectile(firingPlayer, fireInfo, projectileIdx, randomGenerator)
	local localPlayerInitiatedShot = self.player == Players.LocalPlayer

	-- Retrieve config values
	local bulletSpeed = self:getConfigValue("BulletSpeed", 1000)
	local maxDistance = self:getConfigValue("MaxDistance", 2000)
	local trailLength = self:getConfigValue("TrailLength", nil)
	local trailLengthFactor = self:getConfigValue("TrailLengthFactor", 1)
	local showEntireTrailUntilHit = self:getConfigValue("ShowEntireTrailUntilHit", false)
	local gravityFactor = self:getConfigValue("GravityFactor", 0)
	local minSpread = self:getConfigValue("MinSpread", 0)
	local maxSpread = self:getConfigValue("MaxSpread", 0)
	local shouldMovePart = self:getConfigValue("ShouldMovePart", false)
	local explodeOnImpact = self:getConfigValue("ExplodeOnImpact", false)
	local blastRadius = self:getConfigValue("BlastRadius", 8)

	-- Cheat the origin of the shot back if gun tip in wall/object
	if self.tipAttach ~= nil then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local tipDir = tipCFrame.LookVector
		local amountToCheatBack = math.abs((self.instance:FindFirstChild("Handle").Position - tipPos):Dot(tipDir)) + 1
		local gunRay = Ray.new(tipPos - tipDir.Unit * amountToCheatBack, tipDir.Unit * amountToCheatBack)
		local hitPart, hitPoint = Roblox.penetrateCast(gunRay, self:getIgnoreList(localPlayerInitiatedShot))
		if hitPart and math.abs((tipPos - hitPoint).Magnitude) > 0 then
			fireInfo.origin = hitPoint - tipDir.Unit * 0.1
			fireInfo.dir = tipDir.Unit
		end
	end

	local origin, dir = fireInfo.origin, fireInfo.dir

	dir = Roblox.applySpread(dir, randomGenerator, math.rad(minSpread), math.rad(maxSpread))

	-- Initialize variables for visuals/particle effects
	local bulletEffect = self.bulletEffectTemplate:Clone()
	bulletEffect.CFrame = CFrame.new(origin, origin + dir)
	bulletEffect.Parent = workspace.CurrentCamera
	CollectionService:AddTag(bulletEffect, "WeaponsSystemIgnore")

	local leadingParticles = bulletEffect:FindFirstChild("LeadingParticles", true)
	local attachment0 = bulletEffect:FindFirstChild("Attachment0")
	local trailParticles = nil
	if attachment0 then
		trailParticles = attachment0:FindFirstChild("TrailParticles")
	end

	local hitAttach = bulletEffect:FindFirstChild("HitEffect")
	local hitParticles = bulletEffect:FindFirstChild("HitParticles", true)
	local numHitParticles = self:getConfigValue("NumHitParticles", 3)
	local hitSound = bulletEffect:FindFirstChild("HitSound", true)
	local flyingSound = bulletEffect:FindFirstChild("Flying", true)

	local muzzleFlashTime = self:getConfigValue("MuzzleFlashTime", 0.03)
	local muzzleFlashShown = false

	local beamThickness0 = self:getConfigValue("BeamWidth0", 1.5)
	local beamThickness1 = self:getConfigValue("BeamWidth1", 1.8)
	local beamFadeTime = self:getConfigValue("BeamFadeTime", nil)

	-- Enable beam trails for projectile
	local beam0 = bulletEffect:FindFirstChild("Beam0")
	if beam0 then
		beam0.Enabled = true
	end
	local beam1 = bulletEffect:FindFirstChild("Beam1")
	if beam1 then
		beam1.Enabled = true
	end

	-- Emit muzzle particles
	local muzzleParticles = bulletEffect:FindFirstChild("MuzzleParticles", true)
	local numMuzzleParticles = self:getConfigValue("NumMuzzleParticles", 50)
	if muzzleParticles then
		muzzleParticles.Parent.CFrame = CFrame.new(origin, origin + dir)
		local numSteps = 5
		for _ = 1, numSteps do
			muzzleParticles.Parent.Velocity = Vector3.new(localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10))
			muzzleParticles:Emit(numMuzzleParticles / numSteps)
		end
	end

	-- Show muzzle flash
	if self.tipAttach and self.muzzleFlash0 and self.muzzleFlash1 and self.muzzleFlashBeam and projectileIdx == 1 then
		local minFlashRotation, maxFlashRotation = self:getConfigValue("MuzzleFlashRotation0", -math.pi), self:getConfigValue("MuzzleFlashRotation1", math.pi)
		local minFlashSize, maxFlashSize = self:getConfigValue("MuzzleFlashSize0", 1), self:getConfigValue("MuzzleFlashSize1", 1)
		local flashRotation = localRandom:NextNumber(minFlashRotation, maxFlashRotation)
		local flashSize = localRandom:NextNumber(minFlashSize, maxFlashSize)
		local baseCFrame = self.tipAttach.CFrame * CFrame.Angles(0, 0, flashRotation)
		self.muzzleFlash0.CFrame = baseCFrame * CFrame.new(flashSize * -0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)
		self.muzzleFlash1.CFrame = baseCFrame * CFrame.new(flashSize * 0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)

		self.muzzleFlashBeam.Enabled = true
		self.muzzleFlashBeam.Width0 = flashSize
		self.muzzleFlashBeam.Width1 = flashSize
		muzzleFlashShown = true
	end

	-- Play projectile flying sound
	if flyingSound then
		flyingSound:Play()
	end

	-- Enable trail particles
	if trailParticles then
		trailParticles.Enabled = true
	end

	-- Set up parabola for projectile path
	local parabola = Parabola.new()
	parabola:setPhysicsLaunch(origin, dir * bulletSpeed, nil, 35 * -gravityFactor)
	-- More samples for higher gravity since path will be more curved but raycasts can only be straight lines
	if gravityFactor > 0.66 then
		parabola:setNumSamples(3)
	elseif gravityFactor > 0.33 then
		parabola:setNumSamples(2)
	else
		parabola:setNumSamples(1)
	end

	-- Set up/initialize variables used in steppedCallback
	local stepConn = nil
	local pTravelDistance = 0 -- projected travel distance so far if projectile never stops
	local startTime = tick()
	local didHit = false
	local stoppedMotion = false
	local stoppedMotionAt = 0
	local timeSinceStart = 0
	local flyingVisualEffectsFinished = false -- true if all particle effects shown while projectile is flying are done
	local visualEffectsFinishTime = math.huge
	local visualEffectsLingerTime = 0 -- max time any visual effect needs to finish
	if beamFadeTime then
		visualEffectsLingerTime = beamFadeTime
	end
	local hitInfo = {
		sid = fireInfo.id,
		pid = projectileIdx,
		maxDist = maxDistance,
		part = nil,
		p = nil,
		n = nil,
		m = Enum.Material.Air,
		d = 1e9,
	}

	local steppedCallback = function(dt)
		local now = tick()
		timeSinceStart = now - startTime

		local travelDist = bulletSpeed * dt -- distance projectile has travelled since last frame
		trailLength = trailLength or travelDist * trailLengthFactor

		-- Note: the next three variables are all in terms of distance from starting point (which should be tip of current weapon)
		local projBack = pTravelDistance - trailLength -- furthest back part of projectile (including the trail effect, so will be the start of the trail effect if any)
		local projFront = pTravelDistance -- most forward part of projectile
		local maxDist = hitInfo.maxDist or 0 -- before it collides, this is the max distance the projectile can travel. After it collides, this is the hit point

		-- This will make trailing beams render from tip of gun to wherever projectile is until projectile is destroyed
		if showEntireTrailUntilHit then
			projBack = 0
		end

		-- Validate projBack and projFront
		projBack = math.clamp(projBack, 0, maxDist)
		projFront = math.clamp(projFront, 0, maxDist)

		if not didHit then
			-- Check if bullet hit since last frame
			local castProjBack, castProjFront = projFront, projFront + travelDist
			parabola:setDomain(castProjBack, castProjFront)
			local hitPart, hitPoint, hitNormal, hitMaterial, hitT = parabola:findPart(self.ignoreList)

			if hitPart then
				didHit = true
				projFront = castProjBack + hitT * (castProjFront - castProjBack) -- set projFront to point along projectile arc where an object was hit
				parabola:setDomain(projBack, projFront) -- update parabola domain to match new projFront

				-- Update hitInfo
				hitInfo.part = hitPart
				hitInfo.p = hitPoint
				hitInfo.n = hitNormal
				hitInfo.m = hitMaterial
				hitInfo.d = (hitPoint - origin).Magnitude
				hitInfo.t = hitT
				hitInfo.maxDist = projFront -- since the projectile hit, maxDist is now the hitPoint instead of maxDistance

				-- Register hit on clients
				self:onHit(hitInfo)

				-- Notify the server that this projectile hit something from client that initiated the shot
				-- Show hit indicators on gui of client that shot projectile
				if localPlayerInitiatedShot then
					local hitInfoClone = {}
					for hitInfoKey, value in pairs(hitInfo) do
						hitInfoClone[hitInfoKey] = value
					end
					self.weaponsSystem.getRemoteEvent("WeaponHit"):FireServer(self.instance, hitInfoClone)
				end


				-- Deal with all effects that start/stop/change on hit

				-- Disable trail particles
				if trailParticles then
					trailParticles.Enabled = false
				end

				-- Stop bullet flying sound
				if flyingSound and flyingSound.IsPlaying then
					flyingSound:Stop()
				end

				-- Hide the actual projectile model
				if bulletEffect then
					bulletEffect.Transparency = 1
				end

				-- Stop emitting leading particles
				if leadingParticles then
					leadingParticles.Rate = 0
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, leadingParticles.Lifetime.Max)
				end

				-- Show the explosion on clients for explosive projectiles
				if explodeOnImpact then
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPoint + (hitNormal * 0.5)
					explosion.BlastRadius = blastRadius
					explosion.BlastPressure = 0 -- no blast pressure because the real explosion happens on server
					explosion.ExplosionType = Enum.ExplosionType.NoCraters
					explosion.DestroyJointRadiusPercent = 0
					explosion.Visible = true
					if localPlayerInitiatedShot then
						-- Trigger hit indicators on client that initiated the shot if the explosion hit another player/humanoid
						explosion.Hit:Connect(function(explodedPart, hitDist)
							local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
							if humanoid and
							   explodedPart.Name == "UpperTorso" and
							   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
							   self.weaponsSystem.gui and
							   explodedPart.Parent ~= self.player.Character and
							   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
							then
								self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), humanoid)
							end
						end)
					end
					explosion.Parent = workspace
				end

				-- Make sure hitAttach is in correct position before showing hit effects
				if hitAttach and beam0 and beam0.Attachment1 then
					parabola:renderToBeam(beam0)
					hitAttach.CFrame = beam0.Attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
				end

				-- Show hit particle effect
				local hitPartColor = hitPart and hitPart.Color or Color3.fromRGB(255, 255, 255)
				if hitPart and hitPart:IsA("Terrain") then
					hitPartColor = workspace.Terrain:GetMaterialColor(hitMaterial or Enum.Material.Sand)
				end
				if hitInfo.h and hitInfo.h:IsA("Humanoid") and hitParticles and numHitParticles > 0 and hitPart then
					-- Show particle effect for hitting a player/humanoid
					hitParticles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				elseif (not hitInfo.h or not hitInfo.h:IsA("Humanoid")) and hitParticles and numHitParticles > 0 then
					-- Show particle effect for hitting anything else
					if hitPart and self:getConfigValue("HitParticlesUsePartColor", true) then
						local existingSeq = hitParticles.Color
						local newKeypoints = {}

						for i, keypoint in pairs(existingSeq.Keypoints) do
							local newColor = keypoint.Value
							if newColor == Color3.fromRGB(255, 0, 255) then
								newColor = hitPartColor
							end
							newKeypoints[i] = ColorSequenceKeypoint.new(keypoint.Time, newColor)
						end

						hitParticles.Color = ColorSequence.new(newKeypoints)
					end

					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				end

				-- Play hit sound
				if hitSound then
					hitSound:Play()
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitSound.TimeLength)
				end

				-- Manage/show decals, billboards, and models (such as an arrow) that appear where the projectile hit (only if the hit object was not a humanoid/player)
				local hitPointObjectSpace = hitPart.CFrame:pointToObjectSpace(hitPoint)
				local hitNormalObjectSpace = hitPart.CFrame:vectorToObjectSpace(hitNormal)
				if not NO_BULLET_DECALS and
				   hitPart and
				   not hitPart.Parent or not hitPart.Parent:FindFirstChildOfClass("Humanoid") and
				   hitPointObjectSpace and
				   hitNormalObjectSpace and
				   self.hitMarkTemplate
				then
					-- Clone hitMark (this contains all the decals/billboards/models to show on the hit surface)
					local hitMark = self.hitMarkTemplate:Clone()
					hitMark.Parent = hitPart
					CollectionService:AddTag(hitMark, "WeaponsSystemIgnore")

					-- Move/align hitMark to the hit surface
					local incomingVec = parabola:sampleVelocity(1).Unit
					if self:getConfigValue("AlignHitMarkToNormal", true) then
						-- Make hitMark face straight out from surface where projectile hit (good for decals)
						local forward = hitNormalObjectSpace
						local up = incomingVec
						local right = -forward:Cross(up).Unit
						up = forward:Cross(right)
						local orientationCFrame = CFrame.fromMatrix(hitPointObjectSpace + hitNormalObjectSpace * 0.05, right, up, -forward)
						hitMark.CFrame = hitPart.CFrame:toWorldSpace(orientationCFrame)
					else
						-- Make hitmark appear stuck in the hit surface from the direction the projectile came from (good for things like arrows)
						hitMark.CFrame = hitPart.CFrame * CFrame.new(hitPointObjectSpace, hitPointObjectSpace + hitPart.CFrame:vectorToObjectSpace(incomingVec))
					end

					-- Weld hitMark to the hitPart
					local weld = Instance.new("WeldConstraint")
					weld.Part0 = hitMark
					weld.Part1 = hitPart
					weld.Parent = hitMark

					-- Fade glow decal over time
					local glowDecal = hitMark:FindFirstChild("Glow")
					if glowDecal then
						coroutine.wrap(function()
							local heartbeat = RunService.Heartbeat
							for i = 0, 1, 1/60 do
								heartbeat:Wait()
								glowDecal.Transparency = (i ^ 2)
							end
						end)()
					end

					-- Set bullethole decal color and fade over time
					local bulletHole = hitMark:FindFirstChild("BulletHole")
					if bulletHole then
						bulletHole.Color3 = hitPartColor
						TweenService:Create(
							bulletHole,
							TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 4),
							{ Transparency = 1 }
						):Play()
					end

					-- Fade impact billboard's size and transparency over time
					local impactBillboard = hitMark:FindFirstChild("ImpactBillboard")
					if impactBillboard then
						local impact = impactBillboard:FindFirstChild("Impact")
						local impactTween = TweenService:Create(
							impact,
							TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
							{ Size = UDim2.new(1, 0, 1, 0) }
						)
						impactTween.Completed:Connect(function()
							TweenService:Create(
								impact,
								TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
								{ Size = UDim2.new(0.5, 0, 0.5, 0), ImageTransparency = 1 }
							):Play()
						end)
						impactTween:Play()
					end

					-- Destroy hitMark in 5 seconds
					Debris:AddItem(hitMark, 5)
				end

				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Will enter this if-statement if projectile hit something or maxDistance has been reached
		if projFront >= maxDist then
			if not stoppedMotion then
				stoppedMotion = true
				stoppedMotionAt = now
			end

			-- Stop particle effects if projectile didn't hit anything and projBack has reached the end
			if projBack >= maxDist and not flyingVisualEffectsFinished then
				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Update parabola domain
		parabola:setDomain(projBack, projFront)

		-- Continue updating pTravelDistance until projBack has reached maxDist (this helps with some visual effects)
		if projBack < maxDist then
			pTravelDistance = math.max(0, timeSinceStart * bulletSpeed)
		end


		-- Update visual effects each frame

		-- Update CFrame/velocity of projectile if the projectile uses a model (such as rocket or grenade)
		if shouldMovePart then
			local bulletPos = parabola:samplePoint(1)
			local bulletVelocity = parabola:sampleVelocity(1)
			bulletEffect.CFrame = CFrame.new(bulletPos, bulletPos + bulletVelocity)
			bulletEffect.Velocity = bulletVelocity.Unit * bulletSpeed
		end

		-- Update thickness and render trailing beams
		local thickness0 = beamThickness0
		local thickness1 = beamThickness1
		if beamFadeTime then
			-- Fade out trail beams if projectile is no longer moving (hit something or reached max distance)
			local timeSinceEnd = stoppedMotion and (now - stoppedMotionAt) or 0
			local fadeAlpha = math.clamp(timeSinceEnd / beamFadeTime, 0, 1)
			thickness0 = thickness0 * (1 - fadeAlpha)
			thickness1 = thickness1 * (1 - fadeAlpha)
		end
		if beam0 then
			beam0.Width0 = thickness0
			beam0.Width1 = thickness1
			parabola:renderToBeam(beam0)
		end
		if beam1 then
			beam1.Width0 = thickness0
			beam1.Width1 = thickness1
			parabola:renderToBeam(beam1)
		end

		-- Disable muzzle flash after muzzleFlashTime seconds have passed
		if muzzleFlashShown and timeSinceStart > muzzleFlashTime and self.muzzleFlashBeam then
			self.muzzleFlashBeam.Enabled = false
			muzzleFlashShown = false
		end

		-- Destroy projectile and attached visual effects when visual effects are done showing or max bullet time has been reached
		local timeSinceParticleEffectsFinished = now - visualEffectsFinishTime
		if (flyingVisualEffectsFinished and timeSinceParticleEffectsFinished > 0) or timeSinceStart > MAX_BULLET_TIME then
			if bulletEffect then
				bulletEffect:Destroy()
				bulletEffect = nil
			end

			stepConn:Disconnect()
		end
	end

	stepConn = RunService.Heartbeat:Connect(steppedCallback)

	-- Get rid of charge on chargeable weapons
	if not IsServer and self.usesCharging then
		self.charge = math.clamp(self.charge - self:getConfigValue("FireDischarge", 1), 0, 1)
	end
end

function BulletWeapon:calculateDamage(travelDistance)
	local zeroDamageDistance = self:getConfigValue("ZeroDamageDistance", 10000)
	local fullDamageDistance = self:getConfigValue("FullDamageDistance", 1000)
	local distRange = zeroDamageDistance - fullDamageDistance
	local falloff = math.clamp(1 - (math.max(0, travelDistance - fullDamageDistance) / math.max(1, distRange)), 0, 1)
	return math.max(self:getConfigValue("HitDamage", 10) * falloff, 0)
end

function BulletWeapon:applyDamage(hitInfo)
	local damage = self:calculateDamage(hitInfo.d)

	if damage <= 0 then
		return
	end

	self.weaponsSystem.doDamage(hitInfo.h, damage, nil, self.player)
end

function BulletWeapon:onHit(hitInfo)
	local hitPoint = hitInfo.p
	local hitNormal = hitInfo.n
	local hitPart = hitInfo.part

	if hitPart and hitPart.Parent then
		local humanoid = self.weaponsSystem.getHumanoid(hitPart)
		hitInfo.h = humanoid or hitPart

		if IsServer and
		   (not hitInfo.h:IsA("Humanoid") or
		   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player))
		then
			self:applyDamage(hitInfo)
		elseif hitInfo.h:IsA("Humanoid") and
			hitInfo.h:GetState() ~= Enum.HumanoidStateType.Dead and
			self.weaponsSystem.gui and
			self.player == Players.LocalPlayer and
			self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player)
		then
			-- Show hit indicators on gui of client that shot projectile if players are not on same team
			self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), hitInfo.h)
		end
	end

	-- Create invisible explosion on server that deals damage to anything caught in the explosion
	if IsServer and self:getConfigValue("ExplodeOnImpact", false) then
		local blastRadius = self:getConfigValue("BlastRadius", 8)
		local blastPressure = self:getConfigValue("BlastPressure", 10000)
		local blastDamage = self:getConfigValue("BlastDamage", 100)

		local explosion = Instance.new("Explosion")
		explosion.Position = hitPoint + (hitNormal * 0.5)
		explosion.BlastRadius = blastRadius
		explosion.BlastPressure = blastPressure
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.DestroyJointRadiusPercent = 0
		explosion.Visible = false

		explosion.Hit:Connect(function(explodedPart, hitDist)
			local damageMultiplier = (1 - math.clamp((hitDist / blastRadius), 0, 1))
			local damageToDeal = blastDamage * damageMultiplier

			local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
			if humanoid then
				if explodedPart.Name == "UpperTorso" and
				   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
				then
					-- Do damage to players/humanoids
					self.weaponsSystem.doDamage(humanoid, damageToDeal, nil, self.player)
				end
			elseif not CollectionService:HasTag(explodedPart, "WeaponsSystemIgnore") then
				-- Do damage to a part (sends damage to breaking system)
				self.weaponsSystem.doDamage(explodedPart, damageToDeal, nil, self.player)
			end
		end)

		explosion.Parent = workspace
	end
end

function BulletWeapon:fire(origin, dir, charge)
	if not self:isCharged() then
		return
	end

	BaseWeapon.fire(self, origin, dir, charge)
end

function BulletWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer and firingPlayer == Players.LocalPlayer and fromNetwork then
		return
	end

	local cooldownTime = self:getConfigValue("ShotCooldown", 0.1)
	local fireMode = self:getConfigValue("FireMode", "Semiautomatic")
	local isSemiAuto = fireMode == "Semiautomatic"
	local isBurst = fireMode == "Burst"

	if isBurst and not self.burstFiring then
		self.burstIdx = 0
		self.burstFiring = true
	elseif isSemiAuto then
		self.triggerDisconnected = true
	end

	-- Calculate cooldown time for burst firing
	if self.burstFiring then
		self.burstIdx = self.burstIdx + 1
		if self.burstIdx >= self:getConfigValue("NumBurstShots", 3) then
			self.burstFiring = false
			self.triggerDisconnected = true
		else
			cooldownTime = self:getConfigValue("BurstShotCooldown", nil) or cooldownTime
		end
	end

	self.nextFireTime = tick() + cooldownTime

	BaseWeapon.onFired(self, firingPlayer, fireInfo, fromNetwork)
end

function BulletWeapon:onConfigValueChanged(valueName, newValue, oldValue)
	BaseWeapon.onConfigValueChanged(self, valueName, newValue, oldValue)
	if valueName == "ShotEffect" then
		self.bulletEffectTemplate = ShotsFolder:FindFirstChild(self:getConfigValue("ShotEffect", "Bullet"))
		if self.bulletEffectTemplate then
			local config = self.bulletEffectTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end

			local beam0 = self.bulletEffectTemplate:FindFirstChild("Beam0")
			if beam0 then
				coroutine.wrap(function()
					ContentProvider:PreloadAsync({ beam0 })
				end)()
			end
		end
	elseif valueName == "HitMarkEffect" then
		self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))
		if self.hitMarkTemplate then
			local config = self.hitMarkTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "CasingEffect" then
		self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
		if self.casingTemplate then
			local config = self.casingTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "ChargeRate" then
		self.usesCharging = newValue ~= nil
	end
end

function BulletWeapon:onActivatedChanged()
	BaseWeapon.onActivatedChanged(self)

	if not IsServer then
		-- Reload if no ammo left in clip
		if self.equipped and self:getAmmoInWeapon() <= 0 then
			self:reload()
			return
		end

		-- Fire weapon
		if self.activated and self.player == localPlayer and self:canFire() and tick() > self.nextFireTime then
			self:doLocalFire()
		end

		-- Reenable trigger after activated changes to false
		if not self.activated and self.triggerDisconnected and not self.burstFiring then
			self.triggerDisconnected = false
		end
	end
end

function BulletWeapon:onRenderStepped(dt)
	BaseWeapon.onRenderStepped(self, dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	local tipCFrame = self.tipAttach.WorldCFrame

	if self.player == Players.LocalPlayer then
		-- Retrieve aim point from camera and update player's aim animation
		local aimTrack = self:getAnimTrack(self:getConfigValue("AimTrack", "RifleAim"))
		local aimZoomTrack = self:getAnimTrack(self:getConfigValue("AimZoomTrack", "RifleAimDownSights"))
		if aimTrack then
			local aimDir = tipCFrame.LookVector

			local gunLookRay = Ray.new(tipCFrame.p, aimDir * 500)

			local _, gunHitPoint = Roblox.penetrateCast(gunLookRay, self.ignoreList)

			if self.weaponsSystem.aimRayCallback then
				local _, hitPoint = Roblox.penetrateCast(self.weaponsSystem.aimRayCallback(), self.ignoreList)
				self.aimPoint = hitPoint
			else
				self.aimPoint = gunHitPoint
			end

			if not aimTrack.IsPlaying and not self.reloading then
				aimTrack:Play(0.15)
				coroutine.wrap(function() -- prevent player from firing until gun is fully out
					wait(self:getConfigValue("StartupTime", 0.2))
					self.startupFinished = true
				end)()
			end

			if aimZoomTrack and not self.reloading then
				if not aimZoomTrack.IsPlaying then
					aimZoomTrack:Play(0.15)
				end
				aimZoomTrack:AdjustSpeed(0.001)
				if self.weaponsSystem.camera:isZoomed() then
					if aimTrack.WeightTarget ~= 0 then
						aimZoomTrack:AdjustWeight(1)
						aimTrack:AdjustWeight(0)
					end
				elseif aimTrack.WeightTarget ~= 1 then
					aimZoomTrack:AdjustWeight(0)
					aimTrack:AdjustWeight(1)
				end
			end

			local MIN_ANGLE = -80
			local MAX_ANGLE = 80
			local aimYAngle = math.deg(self.recoilIntensity)
			if self.weaponsSystem.camera.enabled then
				-- Gets pitch and recoil from camera to figure out how high/low to aim the gun
				aimYAngle = math.deg(self.weaponsSystem.camera:getRelativePitch() + self.weaponsSystem.camera.currentRecoil.Y + self.recoilIntensity)
			end
			local aimTimePos = 2 * ((aimYAngle - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE))

			aimTrack:AdjustSpeed(0.001)
			aimTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)

			if aimZoomTrack then
				aimZoomTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)
			end

			-- Update recoil (decay over time)
			local recoilDecay = self:getConfigValue("RecoilDecay", 0.825)
			self.recoilIntensity = math.clamp(self.recoilIntensity * recoilDecay, 0, math.huge)
		else
			warn("no aimTrack")
		end
	end
end

function BulletWeapon:setChargingParticles(charge)
	local ratePerCharge = self:getConfigValue("ChargingParticlesRatePerCharge", 20)
	local rate = ratePerCharge * charge
	for _, v in pairs(self.chargingParticles) do
		v.Rate = rate
	end
end

function BulletWeapon:onStepped(dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	BaseWeapon.onStepped(self, dt)

	local now = tick()

	local chargingSound = self:getSound("Charging")
	local dischargingSound = self:getSound("Discharging")

	if self.usesCharging then
		-- Update charge amount
		local chargeBefore = self.charge
		self:handleCharging(dt)
		local chargeDelta = self.charge - chargeBefore

		-- Update charge particles
		if chargeDelta > 0 then
			self:setChargingParticles(self.charge)
		else
			self:setChargingParticles(0)
		end

		-- Play charging sounds
		if chargingSound then
			if chargingSound.Looped then
				if chargeDelta < 0 then
					chargingSound:Stop()
				else
					if not chargingSound.Playing and self.charge < 1 and chargeDelta > 0 then
						chargingSound:Play()
					end
					chargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta > 0 and self.charge <= 1 and not chargingSound.Playing then
					chargingSound.TimePosition = chargingSound.TimeLength * self.charge
					chargingSound:Play()
				elseif chargeDelta <= 0 and chargingSound.Playing then
					chargingSound:Stop()
				end
			end
		end
		if dischargingSound then
			if dischargingSound.Looped then
				if chargeDelta > 0 then
					dischargingSound:Stop()
				else
					if not dischargingSound.Playing and self.charge > 0 then
						dischargingSound:Play()
					end
					dischargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta < 0 and self.charge >= 0 and not dischargingSound.Playing then
					dischargingSound.TimePosition = dischargingSound.TimeLength * self.charge
					dischargingSound:Play()
				elseif chargeDelta >= 0 and dischargingSound.Playing then
					dischargingSound:Stop()
				end
			end
		end

		-- Play charge/discharge completed sounds and particle effects
		if chargeBefore < 1 and self.charge >= 1 then
			local chargeCompleteSound = self:getSound("ChargeComplete")
			if chargeCompleteSound then
				chargeCompleteSound:Play()
			end
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if self.chargeCompleteParticles then
				self.chargeCompleteParticles:Emit(self:getConfigValue("NumChargeCompleteParticles", 25))
			end
		end
		if chargeBefore > 0 and self.charge <= 0 then
			local dischargeCompleteSound = self:getSound("DischargeComplete")
			if dischargeCompleteSound then
				dischargeCompleteSound:Play()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
			if self.dischargeCompleteParticles then
				self.dischargeCompleteParticles:Emit(self:getConfigValue("NumDischargeCompleteParticles", 25))
			end
		end

		self:renderCharge()
	else
		if chargingSound then
			chargingSound:Stop()
		end
		if dischargingSound then
			dischargingSound:Stop()
		end
	end

	if self.usesCharging and self.chargeGlowPart then
		self.chargeGlowPart.Transparency = 1 - self.charge
	end

	-- Fire weapon if it is fully charged
	if self:canFire() and now > self.nextFireTime then
		self:doLocalFire()
	end
end

function BulletWeapon:handleCharging(dt)
	local chargeDelta
	local shouldCharge = self.activated or self.burstFiring or self:getConfigValue("ChargePassively", false)
	if self.reloading or self.triggerDisconnected then
		shouldCharge = false
	end

	if shouldCharge then
		chargeDelta = self:getConfigValue("ChargeRate", 0) * dt
	else
		chargeDelta = self:getConfigValue("DischargeRate", 0) * -dt
	end

	self.charge = math.clamp(self.charge + chargeDelta, 0, 1)
end

function BulletWeapon:isCharged()
	return not self.usesCharging or self.charge >= 1
end

function BulletWeapon:canFire()
	return self.player == Players.LocalPlayer and (self.burstFiring or self.activated) and not self.triggerDisconnected and not self.reloading and self:isCharged() and self.startupFinished
end

function BulletWeapon:doLocalFire()
	if self.tipAttach then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local aimDir = (self.aimPoint - tipPos).Unit

		self:fire(tipPos, aimDir, self.charge)
	end
end

return BulletWeapon
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="134">
      <Properties>
        <string name="Name">Configuration</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="BoolValue" referent="135">
        <Properties>
          <string name="Name">SprintEnabled</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <bool name="Value">true</bool>
        </Properties>
      </Item>
      <Item class="BoolValue" referent="136">
        <Properties>
          <string name="Name">SlowZoomWalkEnabled</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <bool name="Value">true</bool>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="137">
      <Properties>
        <string name="Name">Libraries</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="ModuleScript" referent="138">
        <Properties>
          <string name="Name">DamageBillboardHandler</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0FENzg2MTQxLUVGMkUtNEEzNC1CNjFFLTI2MzMzODM1MTRCRX0=]]></BinaryString>
          <string name="Source">local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

if RunService:IsServer() then return {} end

local localPlayer = Players.LocalPlayer
while not localPlayer do
	Players.PlayerAdded:Wait()
	localPlayer = Players.LocalPlayer
end

local adorneeToBillboardGui = {}

local DamageBillboardHandler = {}

function DamageBillboardHandler:CreateBillboardForAdornee(adornee)
	local billboard = adorneeToBillboardGui[adornee]
	if billboard then
		return billboard
	end

	billboard = Instance.new("BillboardGui")
	billboard.Name = "DamageBillboardGui"
	billboard.Adornee = adornee
	billboard.AlwaysOnTop = true
	billboard.ExtentsOffsetWorldSpace = Vector3.new(0,18,0)
	billboard.Size = UDim2.new(0.42,20,15,0)
	billboard.ResetOnSpawn = false
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	billboard.Parent = localPlayer.PlayerGui
	adorneeToBillboardGui[adornee] = billboard

	local ancestorCon
	ancestorCon = adornee.AncestryChanged:connect(function(child, parent)
		if parent == nil then
			ancestorCon:disconnect()
			ancestorCon = nil

			local adorneeBillboard = adorneeToBillboardGui[adornee]
			adorneeBillboard:Destroy()
			adorneeToBillboardGui[adornee] = nil
		end
	end)

	return billboard
end

function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
	damageAmount = math.ceil(damageAmount)

	local billboard = self:CreateBillboardForAdornee(adornee)

	local randomXPos = math.random(-10,10)/30

	local damageNumber = Instance.new("TextLabel")
	damageNumber.AnchorPoint = Vector2.new(0.5, 1)
	damageNumber.BackgroundTransparency = 1
	damageNumber.BorderSizePixel = 0
	damageNumber.Position = UDim2.fromScale(0.5 + randomXPos,1)
	damageNumber.Size = UDim2.fromScale(0,0.25)
	damageNumber.Font = Enum.Font.GothamBlack
	damageNumber.Text = tostring(damageAmount)
	damageNumber.TextColor3 = Color3.new(0.7,0.7,0.7)
	damageNumber.TextScaled = true
	damageNumber.TextStrokeTransparency = 0
	damageNumber.TextTransparency = 0
	damageNumber.TextXAlignment = Enum.TextXAlignment.Center
	damageNumber.TextYAlignment = Enum.TextYAlignment.Bottom
	damageNumber.Parent = billboard

	local appearTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Elastic,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0) --delayTime
	local appearTween = TweenService:Create(
		damageNumber,
		appearTweenInfo, {
			Size = UDim2.fromScale(1, damageNumber.Size.Y.Scale),
			TextColor3 = Color3.new(1,1,1)
		}
	)

	local upTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Linear,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0.2) --delayTime
	local upTween = TweenService:Create(
		damageNumber,
		upTweenInfo, {
			Position = UDim2.fromScale(damageNumber.Position.X.Scale, 0.25),
			TextTransparency = 1,
			TextStrokeTransparency = 4,
			Rotation = math.random(-5,5)
		}
	)

	local completedCon
	completedCon = upTween.Completed:connect(function()
		completedCon:disconnect()
		completedCon = nil
		damageNumber:Destroy()
	end)

	appearTween:Play()
	upTween:Play()
end

return DamageBillboardHandler</string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="139">
        <Properties>
          <string name="Name">DirectionalIndicatorGuiManager</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezc1QTQ2MTYzLTQ2MkItNEE1OS04OUQ2LTk1RkU0NERGNDdGM30=]]></BinaryString>
          <string name="Source">local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local DirectionalIndicatorGuiManager = {}
DirectionalIndicatorGuiManager.__index = DirectionalIndicatorGuiManager

local function GetConfigValue(config, propertyName, default)
	if config then
		local property = config:FindFirstChild(propertyName)
		if property then
			return property.Value
		end
	end
	return default
end

function DirectionalIndicatorGuiManager.new(weaponsGui)
	local self = setmetatable({}, DirectionalIndicatorGuiManager)
	self.weaponsGui = weaponsGui
	self.connections = {}
	self.enabled = false

	-- Note DI is an abbreviation for DirectionalIndicator
	self.DIFolder = self.weaponsGui.scalingElementsFolder:WaitForChild("DirectionalIndicators")
	self.DIInfo = {}

	for _, DIFrame in ipairs(self.DIFolder:GetChildren()) do
		if DIFrame:IsA("Frame") and DIFrame:FindFirstChildOfClass("ImageLabel") then
			local config = DIFrame:FindFirstChildOfClass("Configuration")
			local name = GetConfigValue(config, "Name", DIFrame.Name)
			self.DIInfo[name] = self:GetDIInfoFromFrame(DIFrame)

			DIFrame.Visible = true
			self.DIInfo[name].image.ImageTransparency = 1
		end
	end

	return self
end

function DirectionalIndicatorGuiManager:GetDIInfoFromFrame(frame)
	local diInfo = {}
	diInfo.frame = frame
	diInfo.image = frame:FindFirstChildOfClass("ImageLabel")
	diInfo.config = frame:FindFirstChildOfClass("Configuration")
	diInfo.active = false
	diInfo.dieOnFade = false -- will only be true for copies of original DIs
	return diInfo
end

function DirectionalIndicatorGuiManager:ActivateDirectionalIndicator(DIName, otherPosition)
	-- Use original DI, or make a copy if it's already active
	local diInfo = self.DIInfo[DIName]
	if not diInfo then
		warn("Warning: invalid name given to ActivateDirectionalIndicator")
		return
	end

	if diInfo.active then
		local newFrame = diInfo.frame:Clone()
		newFrame.Parent = diInfo.frame.Parent
		diInfo = self:GetDIInfoFromFrame(newFrame)
		diInfo.dieOnFade = true
	end
	diInfo.active = true

	-- Update distance from center
	local distanceLevel = GetConfigValue(diInfo.config, "DistanceLevelFromCenter", 6)
	local widthLevel = GetConfigValue(diInfo.config, "WidthLevel", distanceLevel)
	local levelMultiplier = 0.03
	self.weaponsGui.originalScaleAmounts[diInfo.frame] = Vector2.new(widthLevel * levelMultiplier, distanceLevel * levelMultiplier * 2)
	self.weaponsGui:updateScale(diInfo.frame, workspace.CurrentCamera.ViewportSize)

	-- Set initial indicator rotation and transparency
	diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
	diInfo.image.ImageTransparency = GetConfigValue(diInfo.config, "TransparencyBeforeFade", 0)

	-- Update rotation of indicator as player rotates
	coroutine.wrap(function()
		while diInfo.image.ImageTransparency &lt; 1 do
			diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
			RunService.RenderStepped:Wait()
		end

		diInfo.active = false
		if diInfo.dieOnFade then
			diInfo.frame:Destroy()
			diInfo = nil
		end
	end)()

	-- Show indicator for a bit, then fade out
	coroutine.wrap(function()
		wait(GetConfigValue(diInfo.config, "TimeBeforeFade", 1))
		local tweenInfo = TweenInfo.new(GetConfigValue(diInfo.config, "FadeTime", 1))
		local goal = {}
		goal.ImageTransparency = 1
		local tween = TweenService:Create(diInfo.image, tweenInfo, goal)
		tween:Play()
	end)()
end

function DirectionalIndicatorGuiManager:CalculateDIRotation(otherPosition)
	local camera = self.weaponsGui.weaponsSystem.camera
	local localPlayerOffsetPositionXZ = Vector3.new(camera.currentCamera.Focus.X, 0, camera.currentCamera.Focus.Z)
	local otherPlayerPositionXZ = Vector3.new(otherPosition.X, 0, otherPosition.Z)
	local toOtherPlayer = (localPlayerOffsetPositionXZ - otherPlayerPositionXZ).Unit
	local forward = (Vector3.new(camera.currentCFrame.LookVector.X, 0, camera.currentCFrame.LookVector.Z)).Unit
	if toOtherPlayer == Vector3.new() then
		toOtherPlayer = forward
	end
	local dotProduct = forward:Dot(toOtherPlayer)
	local crossProduct = forward:Cross(toOtherPlayer)
	local acosAngle = math.deg(math.acos(dotProduct))
	local asinAngle = math.deg(math.asin(crossProduct.Y))
	if asinAngle >= 0 then
		acosAngle = 360 - acosAngle
	end
	return acosAngle
end

return DirectionalIndicatorGuiManager</string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="140">
        <Properties>
          <string name="Name">Parabola</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0ZBMjhGQjlBLUVDN0UtNEY4OC1BODAzLUMyRTc1OEFFQzdFNn0=]]></BinaryString>
          <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local MIN_HORZ_SPEED = 0.01 --The minimum X and Z velocity for a physical-launch parabola to be considered vertical, helps avoid numerical instability
local DEFAULT_NUM_SAMPLES = RunService:IsServer() and 32 or 32
local DEFAULT_NORMAL = Vector3.new(0, 1, 0)
local ROT_OFFSET = {
	[0] = CFrame.Angles(0, math.rad(90), 0) * CFrame.Angles(math.rad(90), 0, 0),
	[1] = CFrame.Angles(0, math.rad(-90), 0) * CFrame.Angles(math.rad(90), 0, 0)
}
local UP_VECTOR = Vector3.new(0, 1, 0)
local ONE_THIRD, TWO_THIRDS = 1/3, 2/3

local Parabola = {}
Parabola.__index = Parabola

function Parabola.new(a, b, c, x0, x1)
	local self = setmetatable({}, Parabola)

	self.referenceFrame = CFrame.new()

	self.a = a or 1
	self.b = b or 1
	self.c = c or 0

	self.x0 = x0 or 0
	self.x1 = x1 or 10

	self.velocity = Vector2.new()
	self.gravity = 0

	self.numSamples = DEFAULT_NUM_SAMPLES

	return self
end

function Parabola:setPhysicsLaunch(startPoint, velocity, endpointY, gravity)
	gravity = gravity or -workspace.Gravity

	local flatVelocity = velocity * Vector3.new(1, 0, 1)
	if flatVelocity.Magnitude > MIN_HORZ_SPEED then
		self.referenceFrame = CFrame.new(startPoint, startPoint + flatVelocity)
	else
		self.referenceFrame = CFrame.new(startPoint)
	end
	local relativeVelocity = self.referenceFrame:vectorToObjectSpace(velocity)
	local xVelocity, yVelocity = math.max(MIN_HORZ_SPEED, -relativeVelocity.Z), relativeVelocity.Y
	self.a = (0.5 * gravity) * (1 / (xVelocity ^ 2))
	self.b = yVelocity / xVelocity
	self.c = 0

	self.velocity = Vector2.new(xVelocity, yVelocity)
	self.gravity = gravity

	if math.abs(gravity) > 1e-3 then
		self.x0 = 0

		if endpointY and startPoint.Y - endpointY > 0 then
			--y = ax^2 + bx + c
			--0 = ax^2 + bx - y
			--x = (-b +- sqrt(b^2 - 4ac)) / 2a

			local a, b, c = self.a, self.b, startPoint.Y - endpointY
			local det = math.sqrt(b^2 - 4 * a * c)
			local s1, s2 = (-b + det) / (2 * a), (-b - det) / (2 * a)

			self.x1 = math.max(s1, s2)
		else
			self.x1 = math.abs(2 * xVelocity * yVelocity) / math.abs(gravity)
		end
	else
		self.x0 = 0
		self.x1 = 100
	end
end

function Parabola:setNumSamples(numSamples)
	self.numSamples = numSamples
end

function Parabola:setDomain(x0, x1)
	self.x0 = x0
	self.x1 = x1
end

function Parabola:samplePoint(t)
	local a, b, c = self.a, self.b, self.c
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (a * x * x) + (b * x) + c
	return self.referenceFrame:pointToWorldSpace(Vector3.new(0, y, -x))
end

function Parabola:sampleSlope(t)
	local a, b = self.a, self.b
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (2 * a * x) + b
	return y
end

function Parabola:sampleVelocity(t)
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local xVelocity = self.velocity.X
	local xT = x / xVelocity
	local yVelocity = self.velocity.Y + (self.gravity * xT)
	return self.referenceFrame:vectorToWorldSpace(Vector3.new(0, yVelocity, -xVelocity))
end

function Parabola:_penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, UP_VECTOR, Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Parabola:_findPart(funcName, list)
	list = list or {}

	local numSamples = self.numSamples
	local hitPart, hitPoint, hitNormal, hitMaterial, hitT = nil, self.referenceFrame.p, DEFAULT_NORMAL, Enum.Material.Air, 0

	local func = funcName ~= "penetrateCast" and workspace[funcName] or Parabola._penetrateCast

	for i = 1, numSamples do
		local t0 = (i - 1) / numSamples
		local t1 = i / numSamples

		local p0 = self:samplePoint(t0)
		local p1 = self:samplePoint(t1)
		local ray = Ray.new(p0, p1 - p0)

		hitPart, hitPoint, hitNormal, hitMaterial = func(workspace, ray, list)
		if hitPart then
			local hitX = -self.referenceFrame:pointToObjectSpace(hitPoint).Z

			hitT = ((hitX - self.x0) / (self.x1 - self.x0))
			break
		end
	end
	if not hitPart then
		hitT = 1
	end
	return hitPart, hitPoint, hitNormal, hitMaterial, hitT
end

function Parabola:findPart(ignoreList)
	return self:_findPart("penetrateCast", ignoreList)
end
function Parabola:findPartWithWhitelist(whitelist)
	return self:_findPart("FindPartOnRayWithWhitelist", whitelist)
end

function Parabola:findSpheresHit(sphereTable, radius)

end

function Parabola:_setBeamControlPoint(beam, attachment, idx, pos, refFrame)
	local attachmentPos = attachment.WorldPosition
	local vecFromAttachment = pos - attachmentPos
	local curveSize = vecFromAttachment.Magnitude

	attachment.CFrame = refFrame:toObjectSpace(CFrame.new(attachmentPos, pos) * ROT_OFFSET[idx])
	if idx == 0 then
		beam.CurveSize0 = curveSize
	else
		beam.CurveSize1 = curveSize
	end
end

function Parabola:renderToBeam(beam)
	local att0, att1 = beam.Attachment0, beam.Attachment1
	--assert(att0 and att1 and att0.Parent and att0.Parent:IsA("BasePart") and att1.Parent and att1.Parent:IsA("BasePart"), "Beam must have valid attachments that are in a BasePart")

	if not att0.Parent or not att1.Parent then
		return
	end

	local root0, root1 = att0.Parent.CFrame, att1.Parent.CFrame

	local referenceFrame = self.referenceFrame

	local x0, x1 = self.x0, self.x1
	local domain = x1 - x0
	local halfDomain = domain * 0.5
	local p0 = self:samplePoint(0)
	local p1 = self:samplePoint(1)
	local a, b, c = self.a, self.b, self.c
	local x = x0 + (0 * (x1 - x0))
	local cY = ((a * x * x) + (b * x) + c) + self:sampleSlope(0) * halfDomain
	c = referenceFrame:pointToWorldSpace(Vector3.new(0, cY, -(x0 + x1) / 2))
	local c0 = TWO_THIRDS * c + ONE_THIRD * p0
	local c1 = TWO_THIRDS * c + ONE_THIRD * p1

	att0.Position = root0:pointToObjectSpace(p0)
	att1.Position = root1:pointToObjectSpace(p1)

	self:_setBeamControlPoint(beam, att0, 0, c0, root0)
	self:_setBeamControlPoint(beam, att1, 1, c1, root1)
end

return Parabola
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="141">
        <Properties>
          <string name="Name">Ragdoll</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezQxMDRFQkYxLTc5MkItNDQwOC04OURELTZCMEZGMEU2ODZGNH0=]]></BinaryString>
          <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local JOINT_INFO = {
	LeftShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(45))
	},
	LeftElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	LeftWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},
	RightShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(-45))
	},
	RightElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	RightWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},

	Waist = {
		Limits = { Lower = -45, Upper = 30 }
	},
	Neck = {
		Limits = { Cone = 20, Twist = 20 }
	},

	LeftHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(35)),
	},
	LeftKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	LeftAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	},
	RightHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(-35))
	},
	RightKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	RightAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	}
}

local GROUPS = {
	UpperBody = {
		"Waist",
		"Neck",
		"LeftShoulder",
		"RightShoulder",
		"LeftElbow",
		"RightElbow",
		"LeftWrist",
		"RightWrist"
	},
	LowerBody = {
		"LeftHip",
		"RightHip",
		"LeftKnee",
		"RightKnee",
		"LeftAnkle",
		"RightAnkle"
	},
	LeftArm = {
		"LeftShoulder",
		"LeftElbow",
		"LeftWrist",
	},
	RightArm = {
		"RightShoulder",
		"RightElbow",
		"RightWrist"
	},
	LeftLeg = {
		"LeftHip",
		"LeftKnee",
		"LeftAnkle"
	},
	RightLeg = {
		"RightHip",
		"RightKnee",
		"RightAnkle"
	},
}

local Ragdoll = {}
Ragdoll.__index = Ragdoll

function Ragdoll.new(character)
	local self = setmetatable({}, Ragdoll)
	self.character = character
	self.humanoid = character:WaitForChild("Humanoid")

	self.joints = {}
	for jointName, info in pairs(JOINT_INFO) do
		self.joints[jointName] = self:setupJoint(jointName, info)
	end

	return self
end

function Ragdoll:setupJoint(jointName, info)
	if self.joints[jointName] then
		return self.joints[jointName]
	end

	local constraintName = jointName .. "Constraint"
	local rigAttachmentName = jointName .. "RigAttachment"
	local existingConstraint = self.character:FindFirstChild(constraintName, true)
	local existingMotor = self.character:FindFirstChild(jointName, true)
	if not existingMotor then
		return nil
	end

	if existingConstraint or RunService:IsClient() then
		existingConstraint = self.character:WaitForChild(constraintName)
		return {
			constraint = existingConstraint,
			motor = existingMotor,
			ragdolled = existingMotor.Part1 ~= nil
		}
	else
		local constraintType = "HingeConstraint"
		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraintType = "BallSocketConstraint"
		end

		local constraint = Instance.new(constraintType)
		constraint.Name = constraintName
		constraint.Enabled = false
		constraint.Attachment0 = existingMotor.Part0:FindFirstChild(rigAttachmentName)
		constraint.Attachment1 = existingMotor.Part1:FindFirstChild(rigAttachmentName)
		constraint.LimitsEnabled = info.Limits ~= nil

		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraint.UpperAngle = info.Limits.Cone
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = -info.Limits.Twist
			constraint.TwistUpperAngle = info.Limits.Twist
		elseif info.Limits and info.Limits.Lower and info.Limits.Upper then
			constraint.LowerAngle = info.Limits.Lower
			constraint.UpperAngle = info.Limits.Upper
		end

		constraint.Parent = existingMotor.Parent

		return {
			constraint = constraint,
			motor = existingMotor,
			ragdolled = false
		}
	end
end

function Ragdoll:setJointRagdolled(jointName, ragdolled)
	local joint = self.joints[jointName]
	if not joint then return end

	joint.constraint.Enabled = ragdolled
	if joint.motor and joint.motor:IsA("Motor6D") then
		if ragdolled then
			joint.motor.Part1 = nil
		else
			joint.motor.Part1 = joint.motor.Parent
		end
	end
end

function Ragdoll:setGroupRagdolled(groupName, ragdolled)
	local groupJoints = GROUPS[groupName]
	assert(groupJoints, string.format("%s is not a valid ragdoll group", tostring(groupName)))

	for _, jointName in pairs(groupJoints) do
		self:setJointRagdolled(jointName, ragdolled)
	end
end

function Ragdoll:setRagdolled(ragdolled, whitelist)
	for jointName in pairs(self.joints) do
		if not whitelist or whitelist[jointName] then
			self:setJointRagdolled(jointName, ragdolled)
		end
	end
end

function Ragdoll:destroy()
	self:setRagdolled(false)
	for _, joint in pairs(self.joints) do
		if joint.constraint then
			joint.constraint:Destroy()
		end
	end
	self.joints = {}
end

return Ragdoll
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="142">
        <Properties>
          <string name="Name">Roblox</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezVEODc1NTg3LTJBNDctNEYyRi05M0MyLTdEMzM2NUM2OEUzOH0=]]></BinaryString>
          <string name="Source"><![CDATA[local TweenService 		= game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local RunService 		= game:GetService("RunService")
local UserInputService	= game:GetService("UserInputService")

local Roblox = {}

Roblox.Random = Random.new()
Roblox.zeroVector2 = Vector2.new()
Roblox.zeroVector3 = Vector3.new()
Roblox.identityCFrame = CFrame.new()
Roblox.upVector2 = Vector2.new(0, 1)
Roblox.upVector3 = Vector3.new(0, 1, 0)

local guidCharsText = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+./"
local guidChars = {}
for i = 1, #guidCharsText do
	guidChars[i] = guidCharsText:sub(i, i)
end
local guidRandom = Random.new()

function Roblox.newGuid()
	local guid = ""
	for _ = 1, 10 do
		local char = guidRandom:NextInteger(1,#guidChars)
		guid = guid .. guidChars[char]
	end
	return guid
end

function Roblox.isPlaySolo()
	return RunService:IsClient() and RunService:IsServer() and RunService:IsStudio()
end

function Roblox.waitForDescendant(instance, descendantName, timeout)
	timeout = timeout or 60
	local found = instance:FindFirstChild(descendantName, true)
	if found then
		return found
	end

	if timeout < 1e6 and timeout > 0 then
		coroutine.wrap(function()
			wait(timeout)
			if not found then
				warn("Roblox.waitForDescendant(%s, %s) is taking too long")
			end
		end)()
	end

	while not found do
		local newDescendant = instance.DescendantAdded:Wait()
		if newDescendant.Name == descendantName then
			found = newDescendant
			return newDescendant
		end
	end
end

function Roblox.create(className)
	return function(props)
		local instance = Instance.new(className)
		for key, val in pairs(props) do
			if key ~= "Parent" then
				instance[key] = val
			end
		end
		instance.Parent = props.Parent
		return instance
	end
end

function Roblox.weldModel(model)
	local rootPart = model.PrimaryPart
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = rootPart
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

function Roblox.setNetworkOwner(model, owner)
	if not model then warn("Cannot setNetworkOwner on nil model") return end
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			part:SetNetworkOwner(owner)
		end
	end
end

function Roblox.createMotor6D(root, child)
	local motor = Instance.new("Motor6D")
	motor.Part0 = root
	motor.Part1 = child

	motor.C0 = root.CFrame:toObjectSpace(child.CFrame)
	motor.C1 = CFrame.new()

	motor.Parent = root
	return motor
end

function Roblox.getTotalMass(part)
	local allConnected = part:GetConnectedParts(true)
	local total = 0
	for _, v in pairs(allConnected) do
		total = total + v:GetMass()
	end
	return total
end

function Roblox.waitForTween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
	tween.Completed:wait()
end

function Roblox.tween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
end

function Roblox.fadeAway(gui, duration, level)
	duration = duration or 0.5
	level = level or 0

	local tweenInfo = TweenInfo.new(duration)
	local tweenProps = { BackgroundTransparency = 1 }

	if gui:IsA("TextButton") or gui:IsA("TextLabel") or gui:IsA("TextBox") then
		tweenProps.TextTransparency = 1
		tweenProps.TextStrokeTransparency = 1
	elseif gui:IsA("ImageLabel") or gui:IsA("ImageButton") then
		tweenProps.ImageTransparency = 1
	else
		return
	end

	for _, v in pairs(gui:GetChildren()) do
		Roblox.fadeAway(v, duration, level + 1)
	end


	if level == 0 then
		coroutine.wrap(function()
			Roblox.waitForTween(gui, tweenInfo, tweenProps)
			gui:Destroy()
		end)()
	else
		Roblox.tween(gui, tweenInfo, tweenProps)
	end
end

function Roblox.setModelAnchored(model, anchored)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = anchored
		end
	end
end

function Roblox.setModelLocalVisible(model, visible)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = visible and 0 or 1
		elseif part:IsA("SurfaceGui") then
			part.Enabled = visible
		elseif part:IsA("Decal") then
			part.Transparency = visible and 0 or 1
		end
	end
end

function Roblox.forAllTagged(tagName, enterFunc, exitFunc)
	for _, obj in pairs(CollectionService:GetTagged(tagName)) do
		if enterFunc then
			enterFunc(obj, tagName)
		end
	end
	if enterFunc then
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(obj) enterFunc(obj, tagName) end)
	end
	if exitFunc then
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(obj) exitFunc(obj, tagName) end)
	end
end

function Roblox.getHumanoidFromCharacterPart(part)
	local currentNode = part
	while currentNode do
		local humanoid = currentNode:FindFirstChildOfClass("Humanoid")
		if humanoid then return humanoid end
		currentNode = currentNode.Parent
	end
	return nil
end

local addEsEndings = {
	s = true,
	sh = true,
	ch = true,
	x = true,
	z = true
}
local vowels = {
	a = true,
	e = true,
	i = true,
	o = true,
	u = true
}
function Roblox.formatPlural(num, name, wordOnly)
	if num ~= 1 then
		local lastTwo = name:sub(-2):lower()
		local lastOne = name:sub(-1):lower()

		local suffix = "s"
		if addEsEndings[lastTwo] or addEsEndings[lastOne] then
			suffix = "es"
		elseif lastOne == "o" and #lastTwo == 2 then
			local secondToLast = lastTwo:sub(1, 1)
			if not vowels[secondToLast] then
				suffix = "es"
			end
		end
		name = name .. suffix
	end
	if not wordOnly then
		return ("%s %s"):format(Roblox.formatInteger(num), name)
	else
		return name
	end
end

function Roblox.formatNumberTight(number)
	local order = math.log10(number)
	if order >= 3 and order < 6 then
		return ("%.1fK"):format(number / (10^3))
	end
	if order >= 6 and order < 9 then
		return ("%.1fM"):format(number / (10^6))
	end
	if order >= 9 then
		return ("%.1fB"):format(number / (10^9))
	end

	return tostring(math.floor(number + 0.5))
end

function Roblox.formatInteger(amount)
	amount = math.floor(amount + 0.5)
	local formatted = amount
	local numMatches
	repeat
		formatted, numMatches = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
	until numMatches == 0
	return formatted
end

function Roblox.round(val, decimal)
	if decimal then
		return math.floor((val * 10 ^ decimal) + 0.5) / (10 ^ decimal)
	else
		return math.floor(val + 0.5)
	end
end

function Roblox.formatNumber(number)
	local result, integral, fractional

	integral, fractional = math.modf(number)
	result = Roblox.formatInteger(integral)

	if fractional ~= 0 then
		result = result .. "." .. string.sub(tostring(math.abs(fractional)),3)
	end
	if number < 0 then
		result = "-" .. result
	end

	return result
end

function Roblox.isPointInsidePart(point, part)
	local localPos = part.CFrame:pointToObjectSpace(point)
	return math.abs(localPos.X) <= part.Size.X * 0.5 and math.abs(localPos.Y) <= part.Size.Y * 0.5 and math.abs(localPos.Z) <= part.Size.Z * 0.5
end

function Roblox.rayPlaneIntersect(ray, pointOnPlane, planeNormal)
	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Roblox.debugPrint(t, level)
	level = level or 0
	local tabs = string.rep("\t", level)
	if typeof(t) == "table" then
		for key, val in pairs(t) do
			print(tabs, key, "=", val)
			if typeof(val) == "table" then
				Roblox.debugPrint(val, level + 1)
			end
		end
	end
end

local function findInstanceImpl(root, path, getChildFunc)
	local currentInstance = root

	while true do
		local nextChildName
		local nextSeparator = path:find("%.")
		if not nextSeparator then
			nextChildName = path
		else
			nextChildName = path:sub(1, nextSeparator - 1)
			path = path:sub(nextSeparator + 1)
		end

		local child = getChildFunc(currentInstance, nextChildName)
		if child then
			currentInstance = child
		else
			return nil
		end
	end
end

local function findFirstChildImpl(parent, childName)
	return parent:FindFirstChild(childName)
end
local function waitForChildImpl(parent, childName)
	return parent:WaitForChild(childName)
end

function Roblox.findInstance(root, path)
	return findInstanceImpl(root, path, findFirstChildImpl)
end

function Roblox.waitForInstance(root, path)
	return findInstanceImpl(root, path, waitForChildImpl)
end

function Roblox.penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and (not hitPart.CanCollide or CollectionService:HasTag(hitPart, "DroppedItemPart") or CollectionService:HasTag(hitPart, "Hidden")) and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Roblox.posInGuiObject(pos, guiObject)
	local guiMin = guiObject.AbsolutePosition
	local guiMax = guiMin + guiObject.AbsoluteSize
	return pos.X >= guiMin.X and pos.X <= guiMax.X and pos.Y >= guiMin.Y and pos.Y <= guiMax.Y
end

function Roblox.getUTCTime()
	local dateInfo = os.date("!*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d", dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.min, dateInfo.sec)
end

function Roblox.getUTCTimestamp()
	return os.time(os.date("!*t"))
end

local DURATION_TOKENS = {
	{ "years",   "y",  31536000 },
	{ "months",  "mo", 2592000 },
	{ "weeks",   "w",  604800 },
	{ "days",    "d",  86400 },
	{ "hours",   "h",  3600 },
	{ "minutes", "m",  60 },
	{ "seconds", "s",  1 },
}
function Roblox.parseDurationInSeconds(inputStr)
	local tokensFound = {}
	local totalDurationSeconds = 0
	for _, tokenInfo in pairs(DURATION_TOKENS) do
		local numFound = string.match(inputStr, "(%d+)" .. tokenInfo[2])
		if numFound then
			local num = tonumber(numFound) or 0
			if num > 0 then
				table.insert(tokensFound, string.format("%d %s", num, tokenInfo[1]))
			end
			totalDurationSeconds = totalDurationSeconds + (num * tokenInfo[3])
		end
	end

	local outputStr = table.concat(tokensFound, ", ")
	return totalDurationSeconds, outputStr
end

local random = Random.new()
function Roblox.chooseWeighted(choiceTable)
    local sum = 0
    for _, weight in pairs(choiceTable) do
        sum = sum + weight
    end

    local roll = random:NextNumber(0, 1)
    local choiceSum = 0
    for choiceName, weight in pairs(choiceTable) do
        local chance = weight / sum
        if roll >= choiceSum and roll < choiceSum + chance then
            return choiceName
        else
            choiceSum = choiceSum + chance
        end
    end

    return nil
end

function Roblox.hasMatchingTag(instance, tagPattern)
	for _, tagName in pairs(CollectionService:GetTags(instance)) do
		if tagName:match(tagPattern) ~= nil then
			return true
		end
	end
	return false
end

local highlightTweens = setmetatable({}, { __mode = 'k' })
function Roblox.showHighlight(instance, show)
	local highlightInstance = instance:FindFirstChild("Highlight")
	if not highlightInstance or not highlightInstance:IsA("ImageLabel") then
		return
	end

	local existingTween = highlightTweens[instance]
	if existingTween then
		if show then
			return
		else
			existingTween:Cancel()
			highlightTweens[instance] = nil
			highlightInstance.ImageTransparency = 1
		end
	else
		if not show then
			return
		else
			coroutine.wrap(function()
				highlightInstance.ImageTransparency = 1
				local newTween = TweenService:Create(highlightInstance, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, true), { ImageTransparency = 0 })
				highlightTweens[instance] = newTween
				while highlightTweens[instance] == newTween do
					newTween:Play()
					newTween.Completed:Wait()
				end
			end)()
		end
	end
end

function Roblox.getClickVerb(capitalize)
	local verb = "Click"
	if UserInputService.TouchEnabled then
		verb = "Tap"
	end

	if not capitalize then
		verb = verb:lower()
	end
	return verb
end

function Roblox.computeLaunchAngle(relativePoint, launchVelocity)
	local dx, dy = -relativePoint.Z, relativePoint.Y

	local g = workspace.Gravity
	local invRoot = (launchVelocity ^ 4) - (g * ((g * dx * dx) + (2 * dy * launchVelocity * launchVelocity)))
	if invRoot <= 0 then
		return math.pi / 4
	end

	local root = math.sqrt(invRoot)
	local angle1 = math.atan(((launchVelocity * launchVelocity) + root) / (g * dx))
	local angle2 = math.atan(((launchVelocity * launchVelocity) - root) / (g * dx))

	local chosenAngle = math.min(angle1, angle2)

	return chosenAngle
end

function Roblox.getClosestPointOnLine(line0, line1, point, doClamp)
	local lineVec = line1 - line0
	local pointFromLine0 = point - line0

	local dotProduct = lineVec:Dot(pointFromLine0)
	local t = dotProduct / (lineVec.Magnitude ^ 2)
	if doClamp ~= false then
		t = math.clamp(t, 0, 1)
	end
	local pointOnLine = line0:Lerp(line1, t)
	return pointOnLine, t, (point - pointOnLine).Magnitude
end

function Roblox.getClosestPointOnLines(referencePoint, lines)
	local closestPoint, closestDist, closestLine, closestT = nil, math.huge, nil, 0
	for i = 1, #lines do
		local lineA, lineB = lines[i][1], lines[i][2]

		local point, t, dist = Roblox.getClosestPointOnLine(lineA, lineB, referencePoint)
		if dist < closestDist then
			closestPoint = point
			closestDist = dist
			closestLine = i
			closestT = t
		end
	end

	return closestPoint, closestDist, closestLine, closestT
end

function Roblox.getPointInFrontOnLines(referencePoint, forwardOffset, lines)
	local closestPoint, _, closestLine, closestT = Roblox.getClosestPointOnLines(referencePoint, lines)
	if closestPoint then
		local pointOffset = closestPoint
		local offsetBudget = forwardOffset

		if closestLine == 1 and closestT == 0 then
			local beforeDist = (lines[1][1] - Roblox.getClosestPointOnLine(lines[1][1], lines[1][2], referencePoint, false)).Magnitude
			offsetBudget = offsetBudget - beforeDist
		end

		local lineDir = Vector3.new(0, 0, 0)
		while offsetBudget > 0 and closestLine <= #lines do
			local lineA, lineB = lines[closestLine][1], lines[closestLine][2]
			local lineVec = lineB - lineA
			local lineLength = lineVec.Magnitude
			local pointDistAlongLine = (pointOffset - lineA).Magnitude
			local distLeftOnLine = lineLength - pointDistAlongLine
			lineDir = lineVec.Unit

			if offsetBudget > distLeftOnLine then
				offsetBudget = offsetBudget - distLeftOnLine
				pointOffset = lineB
				closestLine = closestLine + 1
			else
				break
			end
		end
		pointOffset = pointOffset + lineDir * offsetBudget

		return pointOffset
	end
	return closestPoint
end

function Roblox.applySpread(unspreadDir, randomGenerator, minSpread, maxSpread)
	local spreadRotation = randomGenerator:NextNumber(-math.pi, math.pi)
	local spreadOffset = randomGenerator:NextNumber(minSpread, maxSpread)
	local spreadTransform = CFrame.fromAxisAngle(Vector3.new(math.cos(spreadRotation), math.sin(spreadRotation), 0), spreadOffset)
	local unspreadCFrame = CFrame.new(Vector3.new(), unspreadDir)
	return (unspreadCFrame * spreadTransform).LookVector
end

return Roblox
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="143">
        <Properties>
          <string name="Name">ShoulderCamera</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezYzQTUwMjA4LUNBRTctNDA1Qi05RDkyLTMzNzY5MTY3OUU5RX0=]]></BinaryString>
          <string name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local LocalPlayer = Players.LocalPlayer
if RunService:IsClient() then
	while not LocalPlayer do
		Players.PlayerAdded:Wait()
		LocalPlayer = Players.LocalPlayer
	end
end
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local CAMERA_RENDERSTEP_NAME = "ShoulderCameraUpdate"
local ZOOM_ACTION_NAME = "ShoulderCameraZoom"
local SPRINT_ACTION_NAME = "ShoulderCameraSprint"
local CONTROLLABLE_HUMANOID_STATES = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.Freefall] = true,
	[Enum.HumanoidStateType.Jumping] = true,
	[Enum.HumanoidStateType.Swimming] = false,
	[Enum.HumanoidStateType.Landed] = true
}

-- Gamepad thumbstick utilities
local k = 0.5
local lowerK = 0.9
local function SCurveTransform(t)
	t = math.clamp(t, -1,1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.25
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end

-- Applies a nonlinear transform to the thumbstick position to serve as the acceleration for camera rotation.
-- See https://www.desmos.com/calculator/xw2ytjpzco for a visual reference.
local function gamepadLinearToCurve(thumbstickPosition)
	return Vector2.new(
		math.clamp(math.sign(thumbstickPosition.X) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.X)))), -1, 1),
		math.clamp(math.sign(thumbstickPosition.Y) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.Y)))), -1, 1))
end


-- Remove back accessories since they frequently block the camera
local function isBackAccessory(instance)
	if instance and instance:IsA("Accessory") then
		local handle = instance:WaitForChild("Handle", 5)
		if handle and handle:IsA("Part") then
			local bodyBackAttachment = handle:WaitForChild("BodyBackAttachment", 5)
			if bodyBackAttachment and bodyBackAttachment:IsA("Attachment") then
				return true
			end

			local waistBackAttachment = handle:WaitForChild("WaistBackAttachment", 5)
			if waistBackAttachment and waistBackAttachment:IsA("Attachment") then
				return true
			end
		end
	end

	return false
end

local function removeBackAccessoriesFromCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		coroutine.wrap(function()
			if isBackAccessory(child) then
				child:Destroy()
			end
		end)()
	end
end

local descendantAddedConnection = nil
local function onCharacterAdded(character)
	removeBackAccessoriesFromCharacter(character)
	descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
		coroutine.wrap(function()
			if isBackAccessory(descendant) then
				descendant:Destroy()
			end
		end)()
	end)
end

local function onCharacterRemoving(character)
	if descendantAddedConnection then
		descendantAddedConnection:Disconnect()
		descendantAddedConnection = nil
	end
end

-- Set up the Local Player
if RunService:IsClient() then
	if LocalPlayer.Character then
		onCharacterAdded(LocalPlayer.Character)
	end
	LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
end


local ShoulderCamera = {}
ShoulderCamera.__index = ShoulderCamera
ShoulderCamera.SpringService = nil

function ShoulderCamera.new(weaponsSystem)
	local self = setmetatable({}, ShoulderCamera)
	self.weaponsSystem = weaponsSystem

	-- Configuration parameters (constants)
	self.fieldOfView = 70
	self.minPitch = math.rad(-75) -- min degrees camera can angle down
	self.maxPitch = math.rad(75) -- max degrees camera can cangle up
	self.normalOffset = Vector3.new(2.25, 2.25, 10.5) -- this is the camera's offset from the player
	self.zoomedOffsetDistance = 8 -- number of studs to zoom in from default offset when zooming
	self.normalCrosshairScale = 1
	self.zoomedCrosshairScale = 0.75
	self.defaultZoomFactor = 1
	self.canZoom = true
	self.zoomInputs = { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }
	self.sprintInputs = { Enum.KeyCode.LeftShift }
	self.mouseRadsPerPixel = Vector2.new(1 / 480, 1 / 480)
	self.zoomedMouseRadsPerPixel = Vector2.new(1 / 1200, 1 / 1200)
	self.touchSensitivity = Vector2.new(1 / 100, 1 / 100)
	self.zoomedTouchSensitivity = Vector2.new(1 / 200, 1 / 200)
	self.touchDelayTime = 0.25 -- max time for a touch to count as a tap (to shoot the weapon instead of control camera),
	                           -- also the amount of time players have to start a second touch after releasing the first time to trigger automatic fire
	self.recoilDecay = 2 -- higher number means faster recoil decay rate
	self.rotateCharacterWithCamera = true
	self.gamepadSensitivityModifier = Vector2.new(0.85, 0.65)
	-- Walk speeds
	self.zoomWalkSpeed = 8
	self.normalWalkSpeed = 16
	self.sprintingWalkSpeed = 24

	-- Current state
	self.enabled = false
	self.yaw = 0
	self.pitch = 0
	self.currentCFrame = CFrame.new()
	self.currentOffset = self.normalOffset
	self.currentRecoil = Vector2.new(0, 0)
	self.currentMouseRadsPerPixel = self.mouseRadsPerPixel
	self.currentTouchSensitivity = self.touchSensitivity
	self.mouseLocked = true
	self.touchPanAccumulator = Vector2.new(0, 0) -- used for touch devices, represents amount the player has dragged their finger since starting a touch
	self.currentTool = nil
	self.sprintingInputActivated = false
	self.desiredWalkSpeed = self.normalWalkSpeed
	self.sprintEnabled = false -- true means player will move faster while doing sprint inputs
	self.slowZoomWalkEnabled = false -- true means player will move slower while doing zoom inputs
	self.desiredFieldOfView = self.fieldOfView
	-- Zoom variables
	self.zoomedFromInput = false -- true if player has performed input to zoom
	self.forcedZoomed = false -- ignores zoomedFromInput and canZoom
	self.zoomState = false -- true if player is currently zoomed in
	self.zoomAlpha = 0
	self.hasScope = false
	self.hideToolWhileZoomed = false
	self.currentZoomFactor = self.defaultZoomFactor
	self.zoomedFOV = self.fieldOfView
	-- Gamepad variables
	self.gamepadPan = Vector2.new(0, 0) -- essentially the amount the gamepad has moved from resting position
	self.movementPan = Vector2.new(0, 0) -- this is for movement (gamepadPan is for camera)
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.lastThumbstickTime = nil
	self.currentGamepadSpeed = 0
	self.lastGamepadVelocity = Vector2.new(0, 0)

	-- Occlusion
	self.lastOcclusionDistance = 0
	self.lastOcclusionReachedTime = 0 -- marks the last time camera was at the true occlusion distance
	self.defaultTimeUntilZoomOut = 0
	self.timeUntilZoomOut = self.defaultTimeUntilZoomOut -- time after lastOcclusionReachedTime that camera will zoom out
	self.timeLastPoppedWayIn = 0 -- this holds the last time camera popped nearly into first person
	self.isZoomingOut = false
	self.tweenOutTime = 0.2
	self.curOcclusionTween = nil
	self.occlusionTweenObject = nil

	-- Side correction (when player is against a wall)
	self.sideCorrectionGoalVector = nil
	self.lastSideCorrectionMagnitude = 0
	self.lastSideCorrectionReachedTime = 0 -- marks the last time the camera was at the true correction distance
	self.revertSideCorrectionSpeedMultiplier = 2 -- speed at which camera reverts the side correction (towards 0 correction)
	self.defaultTimeUntilRevertSideCorrection = 0.75
	self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection -- time after lastSideCorrectionReachedTime that camera will revert the correction
	self.isRevertingSideCorrection = false

	-- Datamodel references
	self.eventConnections = {}
	self.raycastIgnoreList = {}
	self.currentCamera = nil
	self.currentCharacter = nil
	self.currentHumanoid = nil
	self.currentRootPart = nil
	self.controlModule = nil -- used to get player's touch input for moving character
	self.random = Random.new()

	return self
end

function ShoulderCamera:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end
	self.enabled = enabled

	if self.enabled then
		RunService:BindToRenderStep(CAMERA_RENDERSTEP_NAME, Enum.RenderPriority.Camera.Value - 1, function(dt) self:onRenderStep(dt) end)
		ContextActionService:BindAction(ZOOM_ACTION_NAME, function(...) self:onZoomAction(...) end, false, unpack(self.zoomInputs))
		ContextActionService:BindAction(SPRINT_ACTION_NAME, function(...) self:onSprintAction(...) end, false, unpack(self.sprintInputs))

		table.insert(self.eventConnections, LocalPlayer.CharacterAdded:Connect(function(character) self:onCurrentCharacterChanged(character) end))
		table.insert(self.eventConnections, LocalPlayer.CharacterRemoving:Connect(function() self:onCurrentCharacterChanged(nil) end))
		table.insert(self.eventConnections, workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() self:onCurrentCameraChanged(workspace.CurrentCamera) end))
		table.insert(self.eventConnections, UserInputService.InputBegan:Connect(function(inputObj, wasProcessed) self:onInputBegan(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputChanged:Connect(function(inputObj, wasProcessed) self:onInputChanged(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputEnded:Connect(function(inputObj, wasProcessed) self:onInputEnded(inputObj, wasProcessed) end))

		self:onCurrentCharacterChanged(LocalPlayer.Character)
		self:onCurrentCameraChanged(workspace.CurrentCamera)

		-- Make transition to shouldercamera smooth by facing in same direction as previous camera
		local cameraLook = self.currentCamera.CFrame.lookVector
		self.yaw = math.atan2(-cameraLook.X, -cameraLook.Z)
		self.pitch = math.asin(cameraLook.Y)

		self.currentCamera.CameraType = Enum.CameraType.Scriptable

		self:setZoomFactor(self.currentZoomFactor) -- this ensures that zoomedFOV reflecs currentZoomFactor

		workspace.CurrentCamera.CameraSubject = self.currentRootPart

		self.occlusionTweenObject = Instance.new("NumberValue")
		self.occlusionTweenObject.Name = "OcclusionTweenObject"
		self.occlusionTweenObject.Parent = script
		self.occlusionTweenObject.Changed:Connect(function(value)
			self.lastOcclusionDistance = value
		end)

		-- Sets up weapon system to use camera for raycast direction instead of gun look vector
		self.weaponsSystem.aimRayCallback = function()
			local cameraCFrame = self.currentCFrame
			return Ray.new(cameraCFrame.p, cameraCFrame.LookVector * 500)
		end
	else
		RunService:UnbindFromRenderStep(CAMERA_RENDERSTEP_NAME)
		ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
		ContextActionService:UnbindAction(SPRINT_ACTION_NAME)

		if self.currentHumanoid then
			self.currentHumanoid.AutoRotate = true
		end

		if self.currentCamera then
			self.currentCamera.CameraType = Enum.CameraType.Custom
		end

		self:updateZoomState()

		self.yaw = 0
		self.pitch = 0

		for _, conn in pairs(self.eventConnections) do
			conn:Disconnect()
		end
		self.eventConnections = {}

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

function ShoulderCamera:onRenderStep(dt)
	if not self.enabled or
	   not self.currentCamera or
	   not self.currentCharacter or
	   not self.currentHumanoid or
	   not self.currentRootPart
	then
		return
	end

	-- Hide mouse and lock to center if applicable
	if self.mouseLocked and not GuiService:GetEmotesMenuOpen() then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end

	-- Handle gamepad input
	self:processGamepadInput(dt)

	-- Smoothly zoom to desired values
	if self.hasScope then
		ShoulderCamera.SpringService:Target(self, 0.8, 8, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 8, { FieldOfView = self.desiredFieldOfView })
	else
		ShoulderCamera.SpringService:Target(self, 0.8, 3, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 3, { FieldOfView = self.desiredFieldOfView })
	end

	-- Handle walk speed changes
	if self.sprintEnabled or self.slowZoomWalkEnabled then
		self.desiredWalkSpeed = self.normalWalkSpeed
		if self.sprintEnabled and (self.sprintingInputActivated or self:sprintFromTouchInput() or self:sprintFromGamepadInput()) and not self.zoomState then
			self.desiredWalkSpeed = self.sprintingWalkSpeed
		end
		if self.slowZoomWalkEnabled and self.zoomAlpha > 0.1 then
			self.desiredWalkSpeed = self.zoomWalkSpeed
		end

		ShoulderCamera.SpringService:Target(self.currentHumanoid, 0.95, 4, { WalkSpeed = self.desiredWalkSpeed })
	end

	-- Initialize variables used for side correction, occlusion, and calculating camera focus/rotation
	local rootPartPos = self.currentRootPart.CFrame.Position
	local rootPartUnrotatedCFrame = CFrame.new(rootPartPos)
	local yawRotation = CFrame.Angles(0, self.yaw, 0)
	local pitchRotation = CFrame.Angles(self.pitch + self.currentRecoil.Y, 0, 0)
	local xOffset = CFrame.new(self.normalOffset.X, 0, 0)
	local yOffset = CFrame.new(0, self.normalOffset.Y, 0)
	local zOffset = CFrame.new(0, 0, self.normalOffset.Z)
	local collisionRadius = self:getCollisionRadius()
	local cameraYawRotationAndXOffset =
		yawRotation * 		-- First rotate around the Y axis (look left/right)
		xOffset 			-- Then perform the desired offset (so camera is centered to side of player instead of directly on player)
	local cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset

	-- Handle/Calculate side correction when player is adjacent to a wall (so camera doesn't go in the wall)
	local vecToFocus = cameraFocus.p - rootPartPos
	local rayToFocus = Ray.new(rootPartPos, vecToFocus + (vecToFocus.Unit * collisionRadius))
	local hitPart, hitPoint, hitNormal = self:penetrateCast(rayToFocus, self.raycastIgnoreList)
	local currentTime = tick()
	local sideCorrectionGoalVector = Vector3.new() -- if nothing is adjacent to player, goal vector is (0, 0, 0)
	if hitPart then
		hitPoint = hitPoint + (hitNormal * collisionRadius)
		sideCorrectionGoalVector = hitPoint - cameraFocus.p
		if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then -- make it easy for camera to pop closer to player (move left)
			if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection and self.lastSideCorrectionMagnitude ~= 0 then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection * 2 -- double time until revert if popping in repeatedly
			elseif self.lastSideCorrectionMagnitude == 0 and self.timeUntilRevertSideCorrection ~= self.defaultTimeUntilRevertSideCorrection then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection
			end
			self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
			self.lastSideCorrectionReachedTime = currentTime
			self.isRevertingSideCorrection = false
		else
			self.isRevertingSideCorrection = true
		end
	elseif self.lastSideCorrectionMagnitude ~= 0 then
		self.isRevertingSideCorrection = true
	end
	if self.isRevertingSideCorrection then -- make it hard/slow for camera to revert side correction (move right)
		if sideCorrectionGoalVector.Magnitude > self.lastSideCorrectionMagnitude - 1 and sideCorrectionGoalVector.Magnitude ~= 0 then
			self.lastSideCorrectionReachedTime = currentTime -- reset timer if occlusion significantly increased since last frame
		end
		if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection then
			local sideCorrectionChangeAmount = dt * (vecToFocus.Magnitude) * self.revertSideCorrectionSpeedMultiplier
			self.lastSideCorrectionMagnitude = self.lastSideCorrectionMagnitude - sideCorrectionChangeAmount
			if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then
				self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
				self.lastSideCorrectionReachedTime = currentTime
				self.isRevertingSideCorrection = false
			end
		end
	end

	-- Update cameraFocus to reflect side correction
	cameraYawRotationAndXOffset = cameraYawRotationAndXOffset + (-vecToFocus.Unit * self.lastSideCorrectionMagnitude)
	cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset
	self.currentCamera.Focus = cameraFocus

	-- Calculate and apply CFrame for camera
	local cameraCFrameInSubjectSpace =
		cameraYawRotationAndXOffset *
		pitchRotation * 	-- rotate around the X axis (look up/down)
		yOffset *			-- move camera up/vertically
		zOffset				-- move camera back
	self.currentCFrame = rootPartUnrotatedCFrame * cameraCFrameInSubjectSpace

	-- Move camera forward if zoomed in
	if self.zoomAlpha > 0 then
		local trueZoomedOffset = math.max(self.zoomedOffsetDistance - self.lastOcclusionDistance, 0) -- don't zoom too far in if already occluded
		self.currentCFrame = self.currentCFrame:lerp(self.currentCFrame + trueZoomedOffset * self.currentCFrame.LookVector.Unit, self.zoomAlpha)
	end

	self.currentCamera.CFrame = self.currentCFrame

	-- Handle occlusion
	local occlusionDistance = self.currentCamera:GetLargestCutoffDistance(self.raycastIgnoreList)
	if occlusionDistance > 1e-5 then
		occlusionDistance = occlusionDistance + collisionRadius
	end
	if occlusionDistance >= self.lastOcclusionDistance then -- make it easy for the camera to pop in towards the player
		if self.curOcclusionTween ~= nil then
			self.curOcclusionTween:Cancel()
			self.curOcclusionTween = nil
		end
		if currentTime > self.lastOcclusionReachedTime + self.timeUntilZoomOut and self.lastOcclusionDistance ~= 0 then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut * 2 -- double time until zoom out if popping in repeatedly
		elseif self.lastOcclusionDistance == 0  and self.timeUntilZoomOut ~= self.defaultTimeUntilZoomOut then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut
		end

		if occlusionDistance / self.normalOffset.Z > 0.8 and self.timeLastPoppedWayIn == 0 then
			self.timeLastPoppedWayIn = currentTime
		end

		self.lastOcclusionDistance = occlusionDistance
		self.lastOcclusionReachedTime = currentTime
		self.isZoomingOut = false
	else -- make it hard/slow for camera to zoom out
		self.isZoomingOut = true
		if occlusionDistance > self.lastOcclusionDistance - 2 and occlusionDistance ~= 0 then -- reset timer if occlusion significantly increased since last frame
			self.lastOcclusionReachedTime = currentTime
		end

		-- If occlusion pops camera in to almost first person for a short time, pop out instantly
		if currentTime < self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.lastOcclusionDistance / self.normalOffset.Z > 0.8 then
			self.lastOcclusionDistance = occlusionDistance
			self.lastOcclusionReachedTime = currentTime
			self.isZoomingOut = false
		elseif currentTime >= self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.timeLastPoppedWayIn ~= 0 then
			self.timeLastPoppedWayIn = 0
		end
	end

	-- Update occlusion amount if timeout time has passed
	if currentTime >= self.lastOcclusionReachedTime + self.timeUntilZoomOut and not self.zoomState then
		if self.curOcclusionTween == nil then
			self.occlusionTweenObject.Value = self.lastOcclusionDistance
			local tweenInfo = TweenInfo.new(self.tweenOutTime)
			local goal = {}
			goal.Value = self.lastOcclusionDistance - self.normalOffset.Z
			self.curOcclusionTween = TweenService:Create(self.occlusionTweenObject, tweenInfo, goal)
			self.curOcclusionTween:Play()
		end
	end

	-- Apply occlusion to camera CFrame
	local currentOffsetDir = self.currentCFrame.LookVector.Unit
	self.currentCFrame = self.currentCFrame + (currentOffsetDir * self.lastOcclusionDistance)
	self.currentCamera.CFrame = self.currentCFrame

	-- Apply recoil decay
	self.currentRecoil = self.currentRecoil - (self.currentRecoil * self.recoilDecay * dt)

	if self:isHumanoidControllable() and self.rotateCharacterWithCamera then
		self.currentHumanoid.AutoRotate = false
		self.currentRootPart.CFrame = CFrame.Angles(0, self.yaw, 0) + self.currentRootPart.Position -- rotate character to be upright and facing the same direction as camera
		self:applyRootJointFix()
	else
		self.currentHumanoid.AutoRotate = true
	end

	self:handlePartTransparencies()
	self:handleTouchToolFiring()
end

-- This function keeps the held weapon from bouncing up and down too much when you move
function ShoulderCamera:applyRootJointFix()
	if self.rootJoint then
		local translationScale = self.zoomState and Vector3.new(0.25, 0.25, 0.25) or Vector3.new(0.5, 0.5, 0.5)
		local rotationScale = self.zoomState and 0.15 or 0.2
		local rootRotation = self.rootJoint.Part0.CFrame - self.rootJoint.Part0.CFrame.Position
		local rotation = self.rootJoint.Transform - self.rootJoint.Transform.Position
		local yawRotation = CFrame.Angles(0, self.yaw, 0)
		local leadRotation = rootRotation:toObjectSpace(yawRotation)
		local rotationFix = self.rootRigAttach.CFrame
		if self:isHumanoidControllable() then
			rotationFix = self.rootJoint.Transform:inverse() * leadRotation * rotation:Lerp(CFrame.new(), 1 - rotationScale) + (self.rootJoint.Transform.Position * translationScale)
		end

		self.rootJoint.C0 = CFrame.new(self.rootJoint.C0.Position, self.rootJoint.C0.Position + rotationFix.LookVector.Unit)
	end
end

function ShoulderCamera:sprintFromTouchInput()
	local moveVector = nil
	local activeController = nil
	local activeControllerIsTouch = nil
	if self.controlModule then
		moveVector = self.controlModule:GetMoveVector()
		activeController = self.controlModule:GetActiveController()
	end
	if moveVector and activeController then
		activeControllerIsTouch = activeController.thumbstickFrame ~= nil or activeController.thumbpadFrame ~= nil
	end

	if activeControllerIsTouch then
		return (moveVector and moveVector.Magnitude >= 0.9)
	else
		return false
	end
end

function ShoulderCamera:sprintFromGamepadInput()
	return self.movementPan.Magnitude > 0.9
end

function ShoulderCamera:onCurrentCharacterChanged(character)
	self.currentCharacter = character
	if self.currentCharacter then
		self.raycastIgnoreList[1] = self.currentCharacter
		self.currentHumanoid = character:WaitForChild("Humanoid")
		self.currentRootPart = character:WaitForChild("HumanoidRootPart")

		self.rootRigAttach = self.currentRootPart:WaitForChild("RootRigAttachment")
		self.rootJoint = character:WaitForChild("LowerTorso"):WaitForChild("Root")
		self.currentWaist = character:WaitForChild("UpperTorso"):WaitForChild("Waist")
		self.currentWrist = character:WaitForChild("RightHand"):WaitForChild("RightWrist")
		self.wristAttach0 = character:WaitForChild("RightLowerArm"):WaitForChild("RightWristRigAttachment")
		self.wristAttach1 = character:WaitForChild("RightHand"):WaitForChild("RightWristRigAttachment")
		self.rightGripAttachment = character:WaitForChild("RightHand"):WaitForChild("RightGripAttachment")

		self.currentTool = character:FindFirstChildOfClass("Tool")

		self.eventConnections.humanoidDied = self.currentHumanoid.Died:Connect(function()
			self.zoomedFromInput = false
			self:updateZoomState()
		end)
		self.eventConnections.characterChildAdded = character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.currentTool = child
				self:updateZoomState()
			end
		end)
		self.eventConnections.characterChildRemoved = character.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") and self.currentTool == child then
				self.currentTool = character:FindFirstChildOfClass("Tool")
				self:updateZoomState()
			end
		end)

		if Players.LocalPlayer then
			local PlayerScripts = Players.LocalPlayer:FindFirstChild("PlayerScripts")
			if PlayerScripts then
				local PlayerModule = PlayerScripts:FindFirstChild("PlayerModule")
				if PlayerModule then
					self.controlModule = require(PlayerModule:FindFirstChild("ControlModule"))
				end
			end
		end
	else
		if self.eventConnections.humanoidDied then
			self.eventConnections.humanoidDied:Disconnect()
			self.eventConnections.humanoidDied = nil
		end
		if self.eventConnections.characterChildAdded then
			self.eventConnections.characterChildAdded:Disconnect()
			self.eventConnections.characterChildAdded = nil
		end
		if self.eventConnections.characterChildRemoved then
			self.eventConnections.characterChildRemoved:Disconnect()
			self.eventConnections.characterChildRemoved = nil
		end

		self.currentTool = nil
		self.currentHumanoid = nil
		self.currentRootPart = nil
		self.controlModule = nil
	end
end

function ShoulderCamera:onCurrentCameraChanged(camera)
	if self.currentCamera == camera then
		return
	end

	self.currentCamera = camera

	if self.currentCamera then
		self.raycastIgnoreList[2] = self.currentCamera

		if self.eventConnections.cameraTypeChanged then
			self.eventConnections.cameraTypeChanged:Disconnect()
			self.eventConnections.cameraTypeChanged = nil
		end
		self.eventConnections.cameraTypeChanged = self.currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			if self.enabled then
				self.currentCamera.CameraType = Enum.CameraType.Scriptable
			end
		end)
	end
end

function ShoulderCamera:isHumanoidControllable()
	if not self.currentHumanoid then
		return false
	end
	local humanoidState = self.currentHumanoid:GetState()
	return CONTROLLABLE_HUMANOID_STATES[humanoidState] == true
end

function ShoulderCamera:getCollisionRadius()
	if not self.currentCamera then
		return 0
	end
	local viewportSize = self.currentCamera.ViewportSize
	local aspectRatio = viewportSize.X / viewportSize.Y
	local fovRads = math.rad(self.fieldOfView)
	local imageHeight = math.tan(fovRads) * math.abs(self.currentCamera.NearPlaneZ)
	local imageWidth = imageHeight * aspectRatio

	local cornerPos = Vector3.new(imageWidth, imageHeight, self.currentCamera.NearPlaneZ)
	return cornerPos.Magnitude
end

function ShoulderCamera:penetrateCast(ray, ignoreList)
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function ShoulderCamera:getRelativePitch()
	if self.currentRootPart then
		local pitchRotation = CFrame.Angles(self.pitch, 0, 0)
		local relativeRotation = self.currentRootPart.CFrame:toObjectSpace(pitchRotation)
		local relativeLook = relativeRotation.lookVector

		local angle = math.asin(relativeLook.Y)
		return math.clamp(angle, self.minPitch, self.maxPitch)
	end
	return self.pitch
end

function ShoulderCamera:getCurrentFieldOfView()
	if self.zoomState then
		return self.zoomedFOV
	else
		return self.fieldOfView
	end
end

function ShoulderCamera:handlePartTransparencies()
	local partsLookup = {}
	local accoutrementsLookup = {}

	for _, child in pairs(self.currentCharacter:GetChildren()) do
		local hidden = false
		if child:IsA("BasePart") then
			hidden = partsLookup[child.Name] == true
			child.LocalTransparencyModifier = hidden and 1 or 0
		elseif child:IsA("Accoutrement") then
			local descendants = child:GetDescendants()
			local accoutrementParts = {}
			for _, desc in pairs(descendants) do
				if desc:IsA("Attachment") and accoutrementsLookup[desc.Name] then
					hidden = true
				elseif desc:IsA("BasePart") then
					table.insert(accoutrementParts, desc)
				end
			end
			for _, part in pairs(accoutrementParts) do
				part.LocalTransparencyModifier = hidden and 1 or 0
			end
		elseif child:IsA("Tool") then
			hidden = self.zoomState and (self.hasScope or self.hideToolWhileZoomed)
			for _, part in pairs(child:GetDescendants()) do
				if part:IsA("BasePart") then
					part.LocalTransparencyModifier = hidden and 1 or 0
				end
			end
		end
	end
end

function ShoulderCamera:setSprintEnabled(enabled)
	self.sprintEnabled = enabled
end

function ShoulderCamera:setSlowZoomWalkEnabled(enabled)
	self.slowZoomWalkEnabled = enabled
end

function ShoulderCamera:setHasScope(hasScope)
	if self.hasScope == hasScope then
		return
	end

	self.hasScope = hasScope
	self:updateZoomState()
end

function ShoulderCamera:onSprintAction(actionName, inputState, inputObj)
	self.sprintingInputActivated = inputState == Enum.UserInputState.Begin
end


-- Zoom related functions

function ShoulderCamera:isZoomed()
	return self.zoomState
end

function ShoulderCamera:setHideToolWhileZoomed(hide)
	self.hideToolWhileZoomed = hide
end

function ShoulderCamera:setZoomFactor(zoomFactor)
	self.currentZoomFactor = zoomFactor
	local nominalFOVRadians = math.rad(self.fieldOfView)
	local nominalImageHeight = math.tan(nominalFOVRadians / 2)
	local zoomedImageHeight = nominalImageHeight / self.currentZoomFactor
	self.zoomedFOV = math.deg(math.atan(zoomedImageHeight) * 2)
	self:updateZoomState()
end

function ShoulderCamera:resetZoomFactor()
	self:setZoomFactor(self.defaultZoomFactor)
end

function ShoulderCamera:setForceZoomed(zoomed)
	if self.forcedZoomed == zoomed then return end
	self.forcedZoomed = zoomed
	self:updateZoomState()
end

function ShoulderCamera:setZoomedFromInput(zoomedFromInput)
	if self.zoomedFromInput == zoomedFromInput or (self.currentHumanoid and self.currentHumanoid:GetState() == Enum.HumanoidStateType.Dead) then
		return
	end

	self.zoomedFromInput = zoomedFromInput
	self:updateZoomState()
end

function ShoulderCamera:updateZoomState()
	local isZoomed = self.forcedZoomed
	if self.canZoom and not self.forcedZoomed then
		isZoomed = self.zoomedFromInput
	end

	if not self.enabled or not self.currentTool then
		isZoomed = false
	end

	self.zoomState = isZoomed

	self.currentMouseRadsPerPixel = isZoomed and self.zoomedMouseRadsPerPixel or self.mouseRadsPerPixel
	self.currentTouchSensitivity = isZoomed and self.zoomedTouchSensitivity or self.touchSensitivity

	if self.weaponsSystem and self.weaponsSystem.gui then
		self.weaponsSystem.gui:setCrosshairScaleTarget(self.zoomState and self.zoomedCrosshairScale or self.normalCrosshairScale)
		self.weaponsSystem.gui:setCrosshairEnabled(not self.zoomState or not self.hasScope)
		self.weaponsSystem.gui:setScopeEnabled(self.zoomState and self.hasScope)
		if self.currentTool then
			self.currentTool.ManualActivationOnly = self.zoomState and self.hasScope and UserInputService.TouchEnabled
		end
	end

	if self.currentCamera then
		self.desiredFieldOfView = self:getCurrentFieldOfView()
	end
end

function ShoulderCamera:onZoomAction(actionName, inputState, inputObj)
	if not self.enabled or not self.canZoom or not self.currentCamera or not self.currentCharacter or not self.weaponsSystem.currentWeapon then
		self:setZoomedFromInput(false)
		return Enum.ContextActionResult.Pass
	end

	self:setZoomedFromInput(inputState == Enum.UserInputState.Begin)
	return Enum.ContextActionResult.Sink
end


-- Recoil related functions

function ShoulderCamera:setCurrentRecoilIntensity(x, y)
	self.currentRecoil = Vector2.new(x, y)
end

function ShoulderCamera:addRecoil(recoilAmount)
	self.currentRecoil = self.currentRecoil + recoilAmount
end


-- Input related functions

function ShoulderCamera:applyInput(yaw, pitch)
	local yInvertValue = UserGameSettings:GetCameraYInvertValue()
	self.yaw = self.yaw + yaw
	self.pitch = math.clamp(self.pitch + pitch * yInvertValue, self.minPitch, self.maxPitch)
end

function ShoulderCamera:processGamepadInput(dt)
	local gamepadPan = self.gamepadPan
	if gamepadPan then
		gamepadPan = gamepadLinearToCurve(gamepadPan)
		if gamepadPan.X == 0 and gamepadPan.Y == 0 then
			self.lastThumbstickTime = nil
			if self.lastThumbstickPos.X == 0 and self.lastThumbstickPos.Y == 0 then
				self.currentGamepadSpeed = 0
			end
		end

		local finalConstant = 0
		local currentTime = tick()

		if self.lastThumbstickTime then
			local elapsed = (currentTime - self.lastThumbstickTime) * 10
			self.currentGamepadSpeed = self.currentGamepadSpeed + (6 * ((elapsed ^ 2) / 0.7))

			if self.currentGamepadSpeed > 6 then self.currentGamepadSpeed = 6 end

			if self.lastGamepadVelocity then
				local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
				local velocityDeltaMag = (velocity - self.lastGamepadVelocity).Magnitude

				if velocityDeltaMag > 12 then
					self.currentGamepadSpeed = self.currentGamepadSpeed * (20 / velocityDeltaMag)
					if self.currentGamepadSpeed > 6 then
						self.currentGamepadSpeed = 6
					end
				end
			end

			finalConstant = GameSettings.GamepadCameraSensitivity * self.currentGamepadSpeed * dt
			self.lastGamepadVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickTime = currentTime

		local yawInput = -gamepadPan.X * finalConstant * self.gamepadSensitivityModifier.X
		local pitchInput = finalConstant * gamepadPan.Y * GameSettings:GetCameraYInvertValue() * self.gamepadSensitivityModifier.Y

		self:applyInput(yawInput, pitchInput)
	end
end

function ShoulderCamera:handleTouchToolFiring()
	if self.touchObj then
		if self.lastTapEndTime then -- and not (self.zoomState and self.hasScope) then
			local touchTime = tick() - self.lastTapEndTime
			if touchTime < self.touchDelayTime and self.currentTool and self.touchPanAccumulator.Magnitude < 0.5 and not self.firingTool and not self.applyingTouchPan then
				self.firingTool = true
				self.currentTool:Activate()
			end
		end
	else
		if self.currentTool and self.firingTool then
			self.currentTool:Deactivate()
		end
		self.firingTool = false
	end
end

function ShoulderCamera:isTouchPositionForCamera(pos)
	if LocalPlayer then
		local guiObjects = LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
		for _, guiObject in ipairs(guiObjects) do
			if guiObject.Name == "DynamicThumbstickFrame" then
				return false
			end
		end
		return true
	end
	return false
end

function ShoulderCamera:onInputBegan(inputObj, wasProcessed)
	if self.touchObj then
		self.touchObj = nil
		wasProcessed = false
	end

	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		local touchStartPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
		if not wasProcessed and self:isTouchPositionForCamera(touchStartPos) and not self.touchObj then
			self.touchObj = inputObj
			self.touchStartTime = tick()
			self.eventConnections.touchChanged = inputObj.Changed:Connect(function(prop)
				if prop == "Position" then
					local touchTime = tick() - self.touchStartTime

					local newTouchPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
					local delta = (newTouchPos - touchStartPos) * self.currentTouchSensitivity
					local yawInput = -delta.X
					local pitchInput = -delta.Y
					if self.touchPanAccumulator.Magnitude > 0.01 and touchTime > self.touchDelayTime then
						if not self.applyingTouchPan then
							self.applyingTouchPan = true
							self.touchPanAccumulator = Vector2.new(0, 0)
						end
					end
					self:applyInput(yawInput, pitchInput)
					self.touchPanAccumulator = self.touchPanAccumulator + Vector2.new(yawInput, pitchInput)
					touchStartPos = newTouchPos
				end
			end)
		end
	end
end

function ShoulderCamera:onInputChanged(inputObj, wasProcessed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		local yawInput = -inputObj.Delta.X * self.currentMouseRadsPerPixel.X
		local pitchInput = -inputObj.Delta.Y * self.currentMouseRadsPerPixel.Y

		self:applyInput(yawInput, pitchInput)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	end
end

function ShoulderCamera:onInputEnded(inputObj, wasProcessed)
	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(0, 0)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(0, 0)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		if self.touchObj == inputObj then
			if self.eventConnections and self.eventConnections.touchChanged then
				self.eventConnections.touchChanged:Disconnect()
				self.eventConnections.touchChanged = nil
			end

			local touchTime = tick() - self.touchStartTime
			if self.currentTool and self.firingTool then
				self.currentTool:Deactivate()
			elseif self.zoomState and self.hasScope and touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.currentTool:Activate() -- this makes sure to shoot the sniper with a single tap when it is zoomed in
				self.currentTool:Deactivate()
			end
			self.firingTool = false

			self.touchPanAccumulator = Vector2.new(0, 0)
			if touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.lastTapEndTime = tick()
			else
				self.lastTapEndTime = nil
			end
			self.applyingTouchPan = false

			self.gamepadPan = Vector2.new(0, 0)
			self.touchObj = nil
		end
	end
end

return ShoulderCamera
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="144">
        <Properties>
          <string name="Name">SpringService</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0UyMDFFRUM2LTNFQkItNEVENi05N0NFLTI5RDQ3NzQyRDNCOH0=]]></BinaryString>
          <string name="Source"><![CDATA[-- SpringService.lua
-- Binds properties to spring simulations
-- @author Parker Stebbins <pstebbins@roblox.com>

local RunService = game:GetService('RunService')

local LinearSpring = {} do
	LinearSpring.__index = LinearSpring

	local pi = math.pi
	local exp = math.exp
	local sin = math.sin
	local cos = math.cos
	local sqrt = math.sqrt

	function LinearSpring.new(dampingRatio, frequency, goal)
		assert(
			dampingRatio*frequency >= 0,
			'No steady state solution for the given damping ratio & frequency'
		)

		return setmetatable(
			{
				d = dampingRatio, -- Damping ratio - Dimensionless
				f = frequency, -- Undamped frequency - Hertz
				g = goal, -- Goal position - Vector
				v = goal*0, -- Current velocity - Vector
			},
			LinearSpring
		)
	end

	function LinearSpring:setGoal(goal)
		self.g = goal
	end

	function LinearSpring:canSleep()
		return false -- @todo add sleeping
	end

	function LinearSpring:step(dt, p0)

		-- Problem: Advance the spring simulation by t seconds.
		-- Start by taking the ODE of a damped harmonic oscillator:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
		-- Apply some constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- The IVP can now be solved to obtain analytic expressions for X[t] and X'[t].
		-- The solution takes on one of three forms depending on the value of d.

		local d = self.d
		local f = self.f*pi*2 -- cycle/s -> rad/s
		local g = self.g
		local v0 = self.v

		local o = p0 - g
		local decay = exp(-dt*d*f)

		local p1, v1

		if d == 1 then -- Critically damped

			p1 = (v0*dt + o*(f*dt + 1))*decay + g
			v1 = (v0 - (o*f + v0)*(f*dt))*decay

		elseif d < 1 then -- Underdamped

			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- @todo improve stability as d approaches 1

			p1 = (o*i + (v0 + o*(d*f))*j/(f*c))*decay + g
			v1 = (v0*(i*c) - (v0*d + o*f)*j)*(decay/c)

		else -- Overdamped

			local c = sqrt(d*d - 1)

			local r1 = -f*(d - c)
			local r2 = -f*(d + c)

			-- @todo improve stability as d approaches 1

			local co2 = (v0 - o*r1)/(2*f*c)
			local co1 = o - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			p1 = e1 + e2 + g
			v1 = r1*e1 + r2*e2
		end

		self.v = v1

		return p1
	end
end

local LinearValue = {} do
	LinearValue.__index = LinearValue

	function LinearValue.new(...)
		return setmetatable(
			{
				...
			},
			LinearValue
		)
	end

	function LinearValue:__add(rhs)
		-- vector + vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] + rhs[i]
		end

		return out
	end

	function LinearValue:__sub(rhs)
		-- vector - vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] - rhs[i]
		end

		return out
	end

	function LinearValue:__mul(rhs)
		-- vector*scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]*rhs
		end

		return out
	end

	function LinearValue:__div(rhs)
		-- vector/scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]/rhs
		end

		return out
	end
end

local springMetadata = {
	-- Defines a spring type with functions for converting to/from values that the spring can digest
	number = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value)
		end,
		fromIntermediate = function(value)
			return value[1]
		end,
	},

	UDim = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.Scale, value.Offset)
		end,
		fromIntermediate = function(value)
			return UDim.new(value[1], value[2])
		end,
	},

	UDim2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return LinearValue.new(x.Scale, x.Offset, y.Scale, y.Offset)
		end,
		fromIntermediate = function(value)
			return UDim2.new(value[1], value[2], value[3], value[4])
		end,
	},

	Vector2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y)
		end,
		fromIntermediate = function(value)
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y, value.Z)
		end,
		fromIntermediate = function(value)
			return Vector3.new(value[1], value[2], value[3])
		end,
	},
}

local springStates = {} -- {[object] = {[property] = Spring}

local steppedEvent = RunService:IsClient() and RunService.RenderStepped or RunService.Heartbeat
steppedEvent:Connect(function(dt)
	for object, state in pairs(springStates) do
		for name, spring in pairs(state) do
			local oldValue = object[name]
			local meta = assert(springMetadata[typeof(oldValue)])

			local oldIntermediate = meta.toIntermediate(oldValue)
			local newIntermediate = spring:step(dt, oldIntermediate)

			if spring:canSleep() then
				state[name] = nil
			end

			object[name] = meta.fromIntermediate(newIntermediate)
		end

		if not next(state) then
			springStates[object] = nil
		end
	end
end)

local SpringService = {} do
	function SpringService:Target(object, dampingRatio, frequency, properties)
		local state = springStates[object]

		if not state then
			state = {}
			springStates[object] = state
		end

		for name, goal in pairs(properties) do
			local spring = state[name]

			local meta = assert(
				springMetadata[typeof(goal)],
				'Unsupported type: ' .. typeof(goal)
			)
			local intermediateGoal = meta.toIntermediate(goal)

			if spring then
				spring:setGoal(intermediateGoal)
			else
				spring = meta.springType.new(dampingRatio, frequency, intermediateGoal)
				state[name] = spring
			end
		end
	end

	function SpringService:Stop(object, property)
		if property then
			-- Unbind a property
			local state = springStates[object]
			if state then
				state[property] = nil
			end
		else
			-- Unbind all the properties
			springStates[object] = nil
		end
	end
end

return SpringService
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="145">
        <Properties>
          <string name="Name">WeaponsGui</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0UyQUE3MDlBLTg1NjItNDIzNi1CODBDLTJGNEMyNEY0RDVCQ30=]]></BinaryString>
          <string name="Source">local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local WeaponsSystemFolder = script.Parent.Parent
local WeaponData = WeaponsSystemFolder:WaitForChild("WeaponData")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local SpringService = require(Libraries:WaitForChild("SpringService"))

local DirectionalIndicatorGuiManager = require(Libraries:WaitForChild("DirectionalIndicatorGuiManager"))
local DamageBillboardHandler = require(Libraries:WaitForChild("DamageBillboardHandler"))

local WeaponsSystemGuiTemplate = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("WeaponsSystemGui")

local AIM_ON_NORMAL = "rbxassetid://2804583948"
local AIM_OFF_NORMAL = "rbxassetid://2804597178"
local AIM_ON_PRESSED = "rbxassetid://2804598866"
local AIM_OFF_PRESSED = "rbxassetid://2804599869"

local FIRE_NORMAL = "rbxassetid://2804818047"
local FIRE_PRESSED = "rbxassetid://2804818076"

local WeaponsGui = {}
WeaponsGui.__index = WeaponsGui

function WeaponsGui.new(weaponsSystem)
	local self = setmetatable({}, WeaponsGui)
	self.weaponsSystem = weaponsSystem
	self.connections = {}
	self.enabled = false

	self.referenceViewportSize = Vector2.new(1000, 1000) -- viewport size that ui elements in scalingElementsFolder were designed on
	self.scaleWeight = 0.75 -- determines weight of scaling (a higher value increases the degree to which elements are scaled)
	self.originalScaleAmounts = {}

	self.crosshairDampingRatio = 0.9
	self.crosshairFrequency = 3
	self.crosshairScaleTarget = 1
	self.crosshairScale = 1
	self.crosshairWeaponScale = 1
	self.crosshairEnabled = true

	self.scopeEnabled = false
	self.isZoomed = false

	self.gui = WeaponsSystemGuiTemplate:Clone()
	self.gui.Enabled = false

	coroutine.wrap(function()
		self.scalingElementsFolder = self.gui:WaitForChild("ScalingElements")

		self.DirectionalIndicatorGuiManager = DirectionalIndicatorGuiManager.new(self)

		self.crosshairFrame = self.scalingElementsFolder:WaitForChild("Crosshair")
		self.crosshairBottom = self.crosshairFrame:WaitForChild("Bottom")
		self.crosshairLeft = self.crosshairFrame:WaitForChild("Left")
		self.crosshairRight = self.crosshairFrame:WaitForChild("Right")
		self.crosshairTop = self.crosshairFrame:WaitForChild("Top")
		self.origCrosshairScales = {} -- these will be used to size crosshair pieces when screen size changes
		self.origCrosshairScales[self.crosshairBottom] = Vector2.new(self.crosshairBottom.Size.X.Scale, self.crosshairBottom.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairLeft] = Vector2.new(self.crosshairLeft.Size.X.Scale, self.crosshairLeft.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairRight] = Vector2.new(self.crosshairRight.Size.X.Scale, self.crosshairRight.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairTop] = Vector2.new(self.crosshairTop.Size.X.Scale, self.crosshairTop.Size.Y.Scale)
		self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

		self.hitMarker = self.scalingElementsFolder:WaitForChild("HitMarker"):WaitForChild("HitMarkerImage")

		self.scopeFrame = self.gui:WaitForChild("Scope")
		local scopeImage = self.scopeFrame:WaitForChild("ScopeImage")

		self.smallTouchscreen = self.gui:WaitForChild("SmallTouchscreen")
		self.largeTouchscreen = self.gui:WaitForChild("LargeTouchscreen")

		self.smallAimButton = self.smallTouchscreen:WaitForChild("AimButton")
		self.smallAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.largeAimButton = self.largeTouchscreen:WaitForChild("AimButton")
		self.largeAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.smallFireButton = self.smallTouchscreen:WaitForChild("FireButton")
		self.smallFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.smallFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)
		self.largeFireButton = self.largeTouchscreen:WaitForChild("FireButton")
		self.largeFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.largeFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)

		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		self.gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
		self.gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() self:onScreenSizeChanged() end)
		self:onScreenSizeChanged()

		WeaponData.OnClientEvent:Connect(function(cmd, otherPlayerPosition)
			if cmd == "HitByOtherPlayer" then
				self.DirectionalIndicatorGuiManager:ActivateDirectionalIndicator("DamageIndicator", otherPlayerPosition)
			end
		end)

		ContentProvider:PreloadAsync({
			self.crosshairBottom,
			self.crosshairLeft,
			self.crosshairRight,
			self.crosshairTop,
			scopeImage,
			self.smallAimButton,
			self.largeAimButton,
			self.smallFireButton,
			self.largeFireButton,
		})
	end)()

	return self
end

local function getJumpButton()
	if UserInputService.TouchEnabled then
		local touchGui = LocalPlayer.PlayerGui:WaitForChild("TouchGui")
		return touchGui.TouchControlFrame:FindFirstChild("JumpButton")
	end

	return nil
end

function WeaponsGui:onScreenSizeChanged()
	if self.smallTouchscreen and self.largeTouchscreen then
		if UserInputService.TouchEnabled then
			local isSmallScreen
			local jumpButton = getJumpButton()
			if jumpButton then
				isSmallScreen = jumpButton.Size.X.Offset &lt;= 70
			else
				isSmallScreen = self.gui.AbsoluteSize.Y &lt; 600
			end
			self.smallTouchscreen.Visible = isSmallScreen
			self.largeTouchscreen.Visible = not isSmallScreen
		else
			self.smallTouchscreen.Visible = false
			self.largeTouchscreen.Visible = false
		end
	end

	-- Scales all ui elements in scalingElementsFolder based on current screen size relative to self.referenceViewportSize
	local viewportSize = workspace.CurrentCamera.ViewportSize
	for _, child in pairs(self.scalingElementsFolder:GetChildren()) do
		self:updateScale(child, viewportSize)
	end

	self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

	-- Update crosshair sizes...they must use offset because crosshairFrame changes size frequently
	self.crosshairBottom.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairBottom].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairBottom].Y * self.crosshairNormalSize.Y)
	self.crosshairLeft.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairLeft].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairLeft].Y * self.crosshairNormalSize.Y)
	self.crosshairRight.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairRight].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairRight].Y * self.crosshairNormalSize.Y)
	self.crosshairTop.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairTop].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairTop].Y * self.crosshairNormalSize.Y)
end

-- This scales the scale amount non-linearly according to scaleWeight
function WeaponsGui:getWeightedScaleAmount(originalScaleAmount, newScreenDim, referenceScreenDim)
	return (1 - self.scaleWeight) * originalScaleAmount * referenceScreenDim / newScreenDim + self.scaleWeight * originalScaleAmount
end

function WeaponsGui:updateScale(guiObject, viewportSize)
	if guiObject:IsA("GuiObject") then
		local xScale = guiObject.Size.X.Scale
		local yScale = guiObject.Size.Y.Scale
		if xScale ~= 0 or yScale ~= 0 or self.originalScaleAmounts[guiObject] ~= nil then
			if self.originalScaleAmounts[guiObject] == nil then
				self.originalScaleAmounts[guiObject] = Vector2.new(xScale, yScale)
			end

			xScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].X, viewportSize.X, self.referenceViewportSize.X)
			yScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].Y, viewportSize.Y, self.referenceViewportSize.Y)
			guiObject.Size = UDim2.new(xScale, 0, yScale, 0)
		end
		return -- makes it so only the most outer container will be scaled
	end

	for _, child in ipairs(guiObject:GetChildren()) do
		self:updateScale(child, viewportSize)
	end
end

function WeaponsGui:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end

	self.enabled = enabled
	if self.enabled then
		self.connections.renderStepped = RunService.RenderStepped:Connect(function(dt) self:onRenderStepped(dt) end)
	else
		self:setZoomed(false)

		for _, v in pairs(self.connections) do
			v:Disconnect()
		end
		self.connections = {}
	end

	if self.gui then
		self.gui.Enabled = self.enabled
	end
end

function WeaponsGui:setCrosshairEnabled(crosshairEnabled)
	if self.crosshairEnabled == crosshairEnabled then
		return
	end

	self.crosshairEnabled = crosshairEnabled
	if self.crosshairFrame then
		self.crosshairFrame.Visible = self.crosshairEnabled
	end
	if self.hitMarker then
		self.hitMarker.ImageTransparency = 1
		self.hitMarker.Visible = self.crosshairEnabled
	end
end

function WeaponsGui:setScopeEnabled(scopeEnabled)
	if self.scopeEnabled == scopeEnabled then
		return
	end

	self.scopeEnabled = scopeEnabled
	if self.scopeFrame then
		self.scopeFrame.Visible = self.scopeEnabled
	end

	local jumpButton = getJumpButton()

	if self.scopeEnabled then
		self.smallFireButton.Visible = true
		self.largeFireButton.Visible = true

		if jumpButton then
			jumpButton.Visible = false
		end
	else
		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		if jumpButton then
			jumpButton.Visible = true
		end
	end
end

function WeaponsGui:setCrosshairWeaponScale(scale)
	if self.crosshairWeaponScale == scale then
		return
	end

	self.crosshairWeaponScale = scale
end

function WeaponsGui:setCrosshairScaleTarget(target, dampingRatio, frequency)
	if typeof(dampingRatio) == "number" then
		self.crosshairDampingRatio = dampingRatio
	end
	if typeof(frequency) == "number" then
		self.crosshairFrequency = frequency
	end
	if self.crosshairScaleTarget == target then
		return
	end

	self.crosshairScaleTarget = target
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:setCrosshairScale(scale)
	if self.crosshairScale == scale then
		return
	end

	self.crosshairScale = scale
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:OnHitOtherPlayer(damage, humanoidHit) -- show hit indicator, then fade
	self.hitMarker.ImageTransparency = 0
	local tweenInfo = TweenInfo.new(0.8)
	local goal = {}
	goal.ImageTransparency = 1
	local tween = TweenService:Create(self.hitMarker, tweenInfo, goal)
	tween:Play()

	DamageBillboardHandler:ShowDamageBillboard(damage, humanoidHit.Parent:FindFirstChild("Head"))
end

function WeaponsGui:onRenderStepped(dt)
	if not self.enabled then
		return
	end
	if not self.gui then
		return
	end

	if self.crosshairFrame and self.crosshairEnabled then
		local crosshairSize = self.crosshairNormalSize * self.crosshairScale * self.crosshairWeaponScale
		self.crosshairFrame.Size = UDim2.new(0, crosshairSize.X, 0, crosshairSize.Y)
	end
end

function WeaponsGui:setZoomed(zoomed)
	if zoomed == self.isZoomed then
		return
	end

	self.isZoomed = zoomed
	local normalImage = self.isZoomed and AIM_OFF_NORMAL or AIM_ON_NORMAL
	local pressedImage = self.isZoomed and AIM_OFF_PRESSED or AIM_ON_PRESSED

	if self.smallAimButton then
		self.smallAimButton.Image = normalImage
		self.smallAimButton.PressedImage = pressedImage
	end
	if self.largeAimButton then
		self.largeAimButton.Image = normalImage
		self.largeAimButton.PressedImage = pressedImage
	end

	if self.weaponsSystem.camera then
		self.weaponsSystem.camera:setForceZoomed(self.isZoomed)
	end
end

function WeaponsGui:onTouchAimButtonActivated()
	self:setZoomed(not self.isZoomed)
end

function WeaponsGui:onTouchFireButton(inputObj, inputState)
	local currentWeapon = self.weaponsSystem.currentWeapon
	if currentWeapon and currentWeapon.instance and currentWeapon.instance:IsA("Tool") then
		if inputObj.UserInputState == Enum.UserInputState.Begin then
			currentWeapon.instance:Activate()
			if self.smallFireButton then
				self.smallFireButton.Image = FIRE_PRESSED
			end
			if self.largeFireButton then
				self.largeFireButton.Image = FIRE_PRESSED
			end

			inputObj:GetPropertyChangedSignal("UserInputState"):Connect(function()
				if inputObj.UserInputState == Enum.UserInputState.End then
					currentWeapon.instance:Deactivate()
					if self.smallFireButton then
						self.smallFireButton.Image = FIRE_NORMAL
					end
					if self.largeFireButton then
						self.largeFireButton.Image = FIRE_NORMAL
					end
				end
			end)
		end
	end
end

return WeaponsGui</string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="146">
        <Properties>
          <string name="Name">ancestorHasTag</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0I1NDQ2RDFFLUYyMEItNDkwMi05OTVELUQ3MjhDQkQ1N0FDMX0=]]></BinaryString>
          <string name="Source">local CollectionService = game:GetService("CollectionService")

local function ancestorHasTag(instance, tag)
	local currentInstance = instance
	while currentInstance do
		if CollectionService:HasTag(currentInstance, tag) then
			return true
		else
			currentInstance = currentInstance.Parent
		end
	end

	return false
end

return ancestorHasTag</string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="147">
        <Properties>
          <string name="Name">BaseWeapon</string>
          <BinaryString name="AttributesSerialize">
          </BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0JDNDJEQjdGLTJFMUQtNEY1NC1CODVGLUJENUQwNzMwMkQ1Qn0=]]></BinaryString>
          <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local AnimationsFolder = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Animations")

local localRandom = Random.new()

local BaseWeapon = {}
BaseWeapon.__index = BaseWeapon

BaseWeapon.CanAimDownSights = false
BaseWeapon.CanBeReloaded = false
BaseWeapon.CanBeFired = false
BaseWeapon.CanHit = false

function BaseWeapon.new(weaponsSystem, instance)
	assert(instance, "BaseWeapon.new() requires a valid Instance to be attached to.")

	local self = setmetatable({}, BaseWeapon)
	self.connections = {}
	self.descendants = {}
	self.descendantsRegistered = false
	self.optionalDescendantNames = {}
	self.weaponsSystem = weaponsSystem
	self.instance = instance
	self.animController = nil
	self.player = nil
	self.enabled = false
	self.equipped = false
	self.activated = false
	self.nextShotId = 1
	self.activeRenderStepName = nil
	self.curReloadSound = nil

	self.animTracks = {}
	self.sounds = {}
	self.configValues = {}
	self.trackedConfigurations = {}

	self.ammoInWeaponValue = nil

	self.reloading = false
	self.canReload = true

	self:registerDescendants()
	self.connections.descendantAdded = self.instance.DescendantAdded:Connect(function(descendant)
		self:onDescendantAdded(descendant)
	end)

	return self
end

function BaseWeapon:doInitialSetup()
	local selfClass = getmetatable(self)
	self.instanceIsTool = self.instance:IsA("Tool")

	-- Set up child added/removed
	self.connections.childAdded = self.instance.ChildAdded:Connect(function(child)
		self:onChildAdded(child)
	end)
	self.connections.childRemoved = self.instance.ChildRemoved:Connect(function(child)
		self:onChildRemoved(child)
	end)
	for _, child in pairs(self.instance:GetChildren()) do
		self:onChildAdded(child)
	end

	-- Initialize self.ammoInWeaponValue
	if selfClass.CanBeReloaded then
		if IsServer then
			self.ammoInWeaponValue = self.instance:FindFirstChild("CurrentAmmo")
			if not self.ammoInWeaponValue then
				self.ammoInWeaponValue = Instance.new("IntValue")
				self.ammoInWeaponValue.Name = "CurrentAmmo"
				self.ammoInWeaponValue.Value = 0
				self.ammoInWeaponValue.Parent = self.instance
			end
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		else
			self.ammoInWeaponValue = self.instance:WaitForChild("CurrentAmmo")
		end
	end

	self.connections.ancestryChanged = self.instance.AncestryChanged:Connect(function() self:onAncestryChanged() end)
	self:onAncestryChanged()

	-- Set up equipped/unequipped and activated/deactivated
	if self.instanceIsTool then
		self.connections.equipped = self.instance.Equipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(true)
				if self:getAmmoInWeapon() <= 0 then
					-- Have to wait a frame, otherwise the reload animation will not play
					coroutine.wrap(function()
						wait()
						self:reload()
					end)()
				end
			end
		end)
		self.connections.unequipped = self.instance.Unequipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(false)
				if self.reloading then
					self:cancelReload()
				end
			end
		end)
		if self.instance:IsDescendantOf(workspace) and self.player then
			self:setEquipped(true)
		end

		self.connections.activated = self.instance.Activated:Connect(function()
			self:setActivated(true)
		end)
		self.connections.deactivated = self.instance.Deactivated:Connect(function()
			self:setActivated(false)
		end)

		-- Weld handle to weapon primary part
		if IsServer then
			self.handle = self.instance:FindFirstChild("Handle")

			local model = self.instance:FindFirstChildOfClass("Model")
			local handleAttachment = model:FindFirstChild("HandleAttachment", true)

			if self.handle and handleAttachment then
				local handleOffset = model.PrimaryPart.CFrame:toObjectSpace(handleAttachment.WorldCFrame)

				local weld = Instance.new("Weld")
				weld.Name = "HandleWeld"
				weld.Part0 = self.handle
				weld.Part1 = model.PrimaryPart
				weld.C0 = CFrame.new()
				weld.C1 = handleOffset
				weld.Parent = self.handle

				self.handle.Anchored = false
				model.PrimaryPart.Anchored = false
			end
		end
	end
end

function BaseWeapon:registerDescendants()
	if not self.instance then
		error("No instance set yet!")
	end

	if self.descendantsRegistered then
		warn("Descendants already registered!")
		return
	end

	for _, descendant in ipairs(self.instance:GetDescendants()) do
		if self.descendants[descendant.Name] == nil then
			self.descendants[descendant.Name] = descendant
		else
			self.descendants[descendant.Name] = "Multiple"
		end
	end
	self.descendantsRegistered = true
end

function BaseWeapon:addOptionalDescendant(key, descendantName)
	if self.instance == nil then
		error("No instance set yet!")
	end

	if not self.descendantsRegistered then
		error("Descendants not registered!")
	end

	if self.descendants[descendantName] == "Multiple" then
		error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendantName.."\", so you cannot addOptionalDescendant with that descendant name.")
	end

	local found = self.descendants[descendantName]
	if found then
		self[key] = found
		return
	else
		self.optionalDescendantNames[descendantName] = key
	end
end

function BaseWeapon:onDescendantAdded(descendant)
	if self.descendants[descendant.Name] == nil then
		self.descendants[descendant.Name] = descendant
	else
		self.descendants[descendant.Name] = "Multiple"
	end

	local desiredKey = self.optionalDescendantNames[descendant.Name]
	if desiredKey then
		if self.descendants[descendant.Name] == "Multiple" then
			error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendant.Name.."\", so you cannot addOptionalDependency with that descendant name.")
		end
		self[desiredKey] = descendant
		self.optionalDescendantNames[descendant.Name] = nil
	end
end

function BaseWeapon:cleanupConnection(...)
	local args = { ... }
	for _, name in pairs(args) do
		if typeof(name) == "string" and self.connections[name] then
			self.connections[name]:Disconnect()
			self.connections[name] = nil
		end
	end
end

function BaseWeapon:onAncestryChanged()
	if self.instanceIsTool then
		local player = nil
		if self.instance:IsDescendantOf(Players) then
			local parentPlayer = self.instance.Parent.Parent
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		elseif self.instance:IsDescendantOf(workspace) then
			local parentPlayer = Players:GetPlayerFromCharacter(self.instance.Parent)
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		end

		self:setPlayer(player)
	end
end

function BaseWeapon:setPlayer(player)
	if self.player == player then
		return
	end

	self.player = player
end

function BaseWeapon:setEquipped(equipped)
	if self.equipped == equipped then
		return
	end

	self.equipped = equipped
	self:onEquippedChanged()

	if not self.equipped then
		self:stopAnimations()
	end
end

function BaseWeapon:onEquippedChanged()
	if self.activeRenderStepName then
		RunService:UnbindFromRenderStep(self.activeRenderStepName)
		self.activeRenderStepName = nil
	end
	self:cleanupConnection("localStepped")

	if not IsServer and self.weaponsSystem then
		self.weaponsSystem.setWeaponEquipped(self, self.equipped)
		if self.equipped then
			if self.player == Players.LocalPlayer then
				RunService:BindToRenderStep(self.instance:GetFullName(), Enum.RenderPriority.Input.Value, function(dt)
					self:onRenderStepped(dt)
				end)
				self.activeRenderStepName = self.instance:GetFullName()
			end
			self.connections.localStepped = RunService.Heartbeat:Connect(function(dt)
				self:onStepped(dt)
			end)
		end
	end

	if self.instanceIsTool then
		for _, part in pairs(self.instance:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = part ~= self.handle and not self.equipped
			end
		end
	end

	self:setActivated(false)
end

function BaseWeapon:setActivated(activated, fromNetwork)
	if not IsServer and fromNetwork and self.player == Players.LocalPlayer then
		return
	end

	if self.activated == activated then
		return
	end

	self.activated = activated
	if IsServer and not fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponActivated"):FireAllClients(self.player, self.instance, self.activated)
	end

	self:onActivatedChanged()
end

function BaseWeapon:onActivatedChanged()

end

function BaseWeapon:renderFire(fireInfo)

end

function BaseWeapon:simulateFire(fireInfo)

end

function BaseWeapon:isOwnerAlive()
	if self.instance:IsA("Tool") then
		local humanoid = self.instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			return humanoid:GetState() ~= Enum.HumanoidStateType.Dead
		end
	end

	return true
end

function BaseWeapon:fire(origin, dir, charge)
	if not self:isOwnerAlive() or self.reloading then
		return
	end

	if self:useAmmo(1) <= 0 then
		self:reload()
		return
	end

	local fireInfo = {}
	fireInfo.origin = origin
	fireInfo.dir = dir
	fireInfo.charge = math.clamp(charge or 1, 0, 1)
	fireInfo.id = self.nextShotId
	self.nextShotId = self.nextShotId + 1

	if not IsServer then
		self:onFired(self.player, fireInfo, false)
		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireServer(self.instance, fireInfo)
	else
		self:onFired(self.player, fireInfo, false)
	end
end

function BaseWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer then
		if firingPlayer == Players.LocalPlayer and fromNetwork then
			return
		end

		self:simulateFire(firingPlayer, fireInfo)
	else
		if self:useAmmo(1) <= 0 then
			return
		end

		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireAllClients(firingPlayer, self.instance, fireInfo)
	end
end

function BaseWeapon:getConfigValue(valueName, defaultValue)
	if self.configValues[valueName] ~= nil then
		return self.configValues[valueName]
	else
		return defaultValue
	end
end

function BaseWeapon:tryPlaySound(soundName, playbackSpeedRange)
	playbackSpeedRange = playbackSpeedRange or 0

	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	if not soundTemplate then
		return
	end

	local sound = soundTemplate:Clone()
	sound.PlaybackSpeed = sound.PlaybackSpeed + localRandom:NextNumber(-playbackSpeedRange * 0.5, playbackSpeedRange * 0.5)
	sound.Parent = soundTemplate.Parent
	sound:Play()
	coroutine.wrap(function()
		wait(sound.TimeLength / sound.PlaybackSpeed)
		sound:Destroy()
	end)()

	return sound
end

function BaseWeapon:getSound(soundName)
	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	return soundTemplate
end

function BaseWeapon:onDestroyed()

end

function BaseWeapon:onConfigValueAdded(valueObj)
	local valueName = valueObj.Name
	local newValue = valueObj.Value
	self.configValues[valueName] = newValue
	self:onConfigValueChanged(valueName, newValue, nil)

	self.connections["valueChanged:" .. valueName] = valueObj.Changed:Connect(function(changedValue)
		local oldValue = self.configValues[valueName]
		self.configValues[valueName] = changedValue

		self:onConfigValueChanged(valueName, changedValue, oldValue)
	end)
	self.connections["valueRenamed:" .. valueName] = valueObj:GetPropertyChangedSignal("Name"):Connect(function()
		self.configValues[valueName] = nil
		self:cleanupConnection("valueChanged:" .. valueName)
		self:cleanupConnection("valueRenamed:" .. valueName)
		self:onConfigValueAdded(valueObj)
	end)
end

function BaseWeapon:onConfigValueRemoved(valueObj)
	local valueName = valueObj.Name
	self.configValues[valueName] = nil

	self:cleanupConnection("valueChanged:" .. valueName)
	self:cleanupConnection("valueRenamed:" .. valueName)
end

-- This function is used to set configuration values from outside configuration objects/folders
function BaseWeapon:importConfiguration(config)
	if not config or not config:IsA("Configuration") then
		for _, child in pairs(config:GetChildren()) do
			if child:IsA("ValueBase") then
				local valueName = child.Name
				local newValue = child.Value
				local oldValue = self.configValues[valueName]
				self.configValues[valueName] = newValue
				self:onConfigValueChanged(valueName, newValue, oldValue)
			end
		end
	end
end

function BaseWeapon:setConfiguration(config)
	self:cleanupConnection("configChildAdded", "configChildRemoved")
	if not config or not config:IsA("Configuration") then
		return
	end

	for _, child in pairs(config:GetChildren()) do
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end
	self.connections.configChildAdded = config.ChildAdded:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end)
	self.connections.configChildRemoved = config.ChildRemoved:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueRemoved(child)
		end
	end)
end

function BaseWeapon:onChildAdded(child)
	if child:IsA("Configuration") then
		self:setConfiguration(child)
	end
end

function BaseWeapon:onChildRemoved(child)
	if child:IsA("Configuration") then
		self:setConfiguration(nil)
	end
end

function BaseWeapon:onConfigValueChanged(valueName, newValue, oldValue)

end

function BaseWeapon:onRenderStepped(dt)

end

function BaseWeapon:onStepped(dt)

end

function BaseWeapon:getAnimationController()
	if self.animController then
		if not self.instanceIsTool or (self.animController.Parent and self.animController.Parent:IsAncestorOf(self.instance)) then
			return self.animController
		end
	end

	self:setAnimationController(nil)

	if self.instanceIsTool then
		local humanoid = IsServer and self.instance.Parent:FindFirstChildOfClass("Humanoid") or self.instance.Parent:WaitForChild("Humanoid", math.huge)
		local animController = nil
		if not humanoid then
			animController = self.instance.Parent:FindFirstChildOfClass("AnimationController")
		end

		self:setAnimationController(humanoid or animController)
		return self.animController
	end
end

function BaseWeapon:setAnimationController(animController)
	if animController == self.animController then
		return
	end
	self:stopAnimations()
	self.animController = animController
end

function BaseWeapon:stopAnimations()
	for _, track in pairs(self.animTracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
	self.animTracks = {}
end

function BaseWeapon:getAnimTrack(key)
	local track = self.animTracks[key]
	if not track then
		local animController = self:getAnimationController()
		if not animController then
			warn("No animation controller when trying to play ", key)
			return nil
		end

		local animation = AnimationsFolder:FindFirstChild(key)
		if not animation then
			error(string.format("No such animation \"%s\" ", tostring(key)))
		end

		track = animController:LoadAnimation(animation)
		self.animTracks[key] = track
	end

	return track
end

function BaseWeapon:reload(player, fromNetwork)
	if
		not self.equipped or
		self.reloading or
		not self.canReload or
		self:getAmmoInWeapon() == self:getConfigValue("AmmoCapacity", 30)
	then
		return false
	end

	if not IsServer then
		if self.player ~= nil and self.player ~= Players.LocalPlayer then
			return
		end
		self.weaponsSystem.getRemoteEvent("WeaponReloadRequest"):FireServer(self.instance)
		self:onReloaded(self.player)
	else
		self:onReloaded(player, fromNetwork)
		self.weaponsSystem.getRemoteEvent("WeaponReloaded"):FireAllClients(player, self.instance)
	end
end

function BaseWeapon:onReloaded(player, fromNetwork)
	if fromNetwork and player == Players.LocalPlayer then -- make sure localplayer doesn't reload twice
		return
	end

	self.reloading = true
	self.canReload = false

	-- Play reload animation and sound
	if not IsServer then
		local reloadTrackKey = self:getConfigValue("ReloadAnimation", "RifleReload")
		if reloadTrackKey then
			self.reloadTrack = self:getAnimTrack(reloadTrackKey)
			if self.reloadTrack then
				self.reloadTrack:Play()
			end
		end

		self.curReloadSound = self:tryPlaySound("Reload", nil)
		if self.curReloadSound then
			self.curReloadSound.Ended:Connect(function()
				self.curReloadSound = nil
			end)
		end
	end

	local reloadTime = self:getConfigValue("ReloadTime", 2)
	local startTime = tick()

	if self.connections.reload ~= nil then -- this prevents an endless ammo bug
		return
	end
	self.connections.reload = RunService.Heartbeat:Connect(function()
		-- Stop trying to reload if the player unequipped this weapon or reloading was canceled some other way
		if not self.reloading then
			if self.connections.reload then
				self.connections.reload:Disconnect()
				self.connections.reload = nil
			end
		end

		-- Wait until gun finishes reloading
		if tick() < startTime + reloadTime then
			return
		end

		-- Add ammo to weapon
		if self.ammoInWeaponValue then
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		end

		if self.connections.reload then
			self.connections.reload:Disconnect()
			self.connections.reload = nil
		end

		self.reloading = false
		self.canReload = false
	end)
end

function BaseWeapon:cancelReload(player, fromNetwork)
	if not self.reloading then
		return
	end
	if fromNetwork and player == Players.LocalPlayer then
		return
	end

	if not IsServer and not fromNetwork and player == Players.LocalPlayer then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireServer(self.instance)
	elseif IsServer and fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireAllClients(player, self.instance)
	end

	self.reloading = false
	self.canReload = true

	if not IsServer and self.reloadTrack and self.reloadTrack.IsPlaying then
		warn("Stopping reloadTrack")
		self.reloadTrack:Stop()
	end
	if self.curReloadSound then
		self.curReloadSound:Stop()
		self.curReloadSound:Destroy()
		self.curReloadSound = nil
	end
end

function BaseWeapon:getAmmoInWeapon()
	if self.ammoInWeaponValue then
		return self.ammoInWeaponValue.Value
	end
	return 0
end

function BaseWeapon:useAmmo(amount)
	if self.ammoInWeaponValue then
		local ammoUsed = math.min(amount, self.ammoInWeaponValue.Value)
		self.ammoInWeaponValue.Value = self.ammoInWeaponValue.Value - ammoUsed
		self.canReload = true
		return ammoUsed
	else
		return 0
	end
end

function BaseWeapon:renderCharge()

end

return BaseWeapon
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="148">
      <Properties>
        <string name="Name">WeaponsSystem</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <Content name="LinkedSource">
          <null>
          </null>
        </Content>
        <BinaryString name="ScriptGuid"><![CDATA[ezNFQzNGNjQyLTlFNjYtNEFBMy05OEMyLUEwQzlFRUZFNTkzNX0=]]></BinaryString>
        <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

-- Dependencies
local WeaponData = script.Parent:WaitForChild("WeaponData")
local WeaponsSystemFolder = script.Parent
local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local ShoulderCamera = require(Libraries:WaitForChild("ShoulderCamera"))
local WeaponsGui = require(Libraries:WaitForChild("WeaponsGui"))
local SpringService = require(Libraries:WaitForChild("SpringService"))
local ancestorHasTag = require(Libraries:WaitForChild("ancestorHasTag"))
ShoulderCamera.SpringService = SpringService

local Configuration = WeaponsSystemFolder:WaitForChild("Configuration")
local ConfigurationValues = {
	SprintEnabled = Configuration:WaitForChild("SprintEnabled"),
	SlowZoomWalkEnabled = Configuration:WaitForChild("SlowZoomWalkEnabled"),
}

local WEAPON_TAG = "WeaponsSystemWeapon"
local WEAPON_TYPES_LOOKUP = {}

local REMOTE_EVENT_NAMES = {
	"WeaponFired",
	"WeaponHit",
	"WeaponReloadRequest",
	"WeaponReloaded",
	"WeaponReloadCanceled",
	"WeaponActivated"
}
local REMOTE_FUNCTION_NAMES = {}

--Set up WeaponTypes lookup table
do
	local function onNewWeaponType(weaponTypeModule)
		if not weaponTypeModule:IsA("ModuleScript") then
			return
		end
		local weaponTypeName = weaponTypeModule.Name
		xpcall(function()
			coroutine.wrap(function()
				local weaponType = require(weaponTypeModule)
				assert(typeof(weaponType) == "table", string.format("WeaponType \"%s\" did not return a valid table", weaponTypeModule:GetFullName()))
				WEAPON_TYPES_LOOKUP[weaponTypeName] = weaponType
			end)()
		end, function(errMsg)
			warn(string.format("Error while loading %s: %s", weaponTypeModule:GetFullName(), errMsg))
			warn(debug.traceback())
		end)
	end
	for _, child in pairs(WeaponTypes:GetChildren()) do
		onNewWeaponType(child)
	end
	WeaponTypes.ChildAdded:Connect(onNewWeaponType)
end

local WeaponsSystem = {}
WeaponsSystem.didSetup = false
WeaponsSystem.knownWeapons = {}
WeaponsSystem.connections = {}
WeaponsSystem.networkFolder = nil
WeaponsSystem.remoteEvents = {}
WeaponsSystem.remoteFunctions = {}
WeaponsSystem.currentWeapon = nil
WeaponsSystem.aimRayCallback = nil

WeaponsSystem.CurrentWeaponChanged = Instance.new("BindableEvent")

local NetworkingCallbacks = require(WeaponsSystemFolder:WaitForChild("NetworkingCallbacks"))
NetworkingCallbacks.WeaponsSystem = WeaponsSystem

local _damageCallback = nil
local _getTeamCallback = nil

function WeaponsSystem.setDamageCallback(cb)
	_damageCallback = cb
end

function WeaponsSystem.setGetTeamCallback(cb)
	_getTeamCallback = cb
end

function WeaponsSystem.setup()
	if WeaponsSystem.didSetup then
		warn("Warning: trying to run WeaponsSystem setup twice on the same module.")
		return
	end
	print(script.Parent:GetFullName(), "is now active.")

	WeaponsSystem.doingSetup = true

	--Setup network routing
	if IsServer then
		local networkFolder = Instance.new("Folder")
		networkFolder.Name = "Network"

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			local remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = remoteEventName
			remoteEvent.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteEventName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteEvent \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnServerEvent:Connect(function(...)
				callback(...)
			end)
			WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			local remoteFunc = Instance.new("RemoteEvent")
			remoteFunc.Name = remoteFuncName
			remoteFunc.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteFuncName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteFunction \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			remoteFunc.OnServerInvoke = function(...)
				return callback(...)
			end
			WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
		end

		networkFolder.Parent = WeaponsSystemFolder
		WeaponsSystem.networkFolder = networkFolder
	else
		WeaponsSystem.StarterGui = game:GetService("StarterGui")

		WeaponsSystem.camera = ShoulderCamera.new(WeaponsSystem)
		WeaponsSystem.gui = WeaponsGui.new(WeaponsSystem)

		if ConfigurationValues.SprintEnabled.Value then
			WeaponsSystem.camera:setSprintEnabled(ConfigurationValues.SprintEnabled.Value)
		end
		
		if ConfigurationValues.SlowZoomWalkEnabled.Value then
			WeaponsSystem.camera:setSlowZoomWalkEnabled(ConfigurationValues.SlowZoomWalkEnabled.Value)
		end

		local networkFolder = WeaponsSystemFolder:WaitForChild("Network", math.huge)

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			coroutine.wrap(function()
				local remoteEvent = networkFolder:WaitForChild(remoteEventName, math.huge)
				local callback = NetworkingCallbacks[remoteEventName]
				if callback then
					WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnClientEvent:Connect(function(...)
						callback(...)
					end)
				end
				WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
			end)()
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			coroutine.wrap(function()
				local remoteFunc = networkFolder:WaitForChild(remoteFuncName, math.huge)
				local callback = NetworkingCallbacks[remoteFuncName]
				if callback then
					remoteFunc.OnClientInvoke = function(...)
						return callback(...)
					end
				end
				WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
			end)()
		end

		Players.LocalPlayer.CharacterAdded:Connect(WeaponsSystem.onCharacterAdded)
		if Players.LocalPlayer.Character then
			WeaponsSystem.onCharacterAdded(Players.LocalPlayer.Character)
		end

		WeaponsSystem.networkFolder = networkFolder
		WeaponsSystem.camera:setEnabled(true)
	end

	--Setup weapon tools and listening
	WeaponsSystem.connections.weaponAdded = CollectionService:GetInstanceAddedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponAdded)
	WeaponsSystem.connections.weaponRemoved = CollectionService:GetInstanceRemovedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponRemoved)

	for _, instance in pairs(CollectionService:GetTagged(WEAPON_TAG)) do
		WeaponsSystem.onWeaponAdded(instance)
	end

	WeaponsSystem.doingSetup = false
	WeaponsSystem.didSetup = true
end

function WeaponsSystem.onCharacterAdded(character)
	-- Make it so players unequip weapons while seated, then reequip weapons when they become unseated
	local humanoid = character:WaitForChild("Humanoid")
	WeaponsSystem.connections.seated = humanoid.Seated:Connect(function(isSeated)
		if isSeated then
			WeaponsSystem.seatedWeapon = character:FindFirstChildOfClass("Tool")
			humanoid:UnequipTools()
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		else
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			humanoid:EquipTool(WeaponsSystem.seatedWeapon)
		end
	end)
end

function WeaponsSystem.shutdown()
	if not WeaponsSystem.didSetup then
		return
	end

	for _, weapon in pairs(WeaponsSystem.knownWeapons) do
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons = {}

	if IsServer and WeaponsSystem.networkFolder then
		WeaponsSystem.networkFolder:Destroy()
	end
	WeaponsSystem.networkFolder = nil
	WeaponsSystem.remoteEvents = {}
	WeaponsSystem.remoteFunctions = {}

	for _, connection in pairs(WeaponsSystem.connections) do
		if typeof(connection) == "RBXScriptConnection" then
			connection:Disconnect()
		end
	end
	WeaponsSystem.connections = {}
end

function WeaponsSystem.getWeaponTypeFromTags(instance)
	for _, tag in pairs(CollectionService:GetTags(instance)) do
		local weaponTypeFound = WEAPON_TYPES_LOOKUP[tag]
		if weaponTypeFound then
			return weaponTypeFound
		end
	end

	return nil
end

function WeaponsSystem.createWeaponForInstance(weaponInstance)
	coroutine.wrap(function()
		local weaponType = WeaponsSystem.getWeaponTypeFromTags(weaponInstance)
		if not weaponType then
			local weaponTypeObj = weaponInstance:WaitForChild("WeaponType")

			if weaponTypeObj and weaponTypeObj:IsA("StringValue") then
				local weaponTypeName = weaponTypeObj.Value
				local weaponTypeFound = WEAPON_TYPES_LOOKUP[weaponTypeName]
				if not weaponTypeFound then
					warn(string.format("Cannot find the weapon type \"%s\" for the instance %s!", weaponTypeName, weaponInstance:GetFullName()))
					return
				end

				weaponType = weaponTypeFound
			else
				warn("Could not find a WeaponType tag or StringValue for the instance ", weaponInstance:GetFullName())
				return
			end
		end

		-- Since we might have yielded while trying to get the WeaponType, we need to make sure not to continue
		-- making a new weapon if something else beat this iteration.
		if WeaponsSystem.getWeaponForInstance(weaponInstance) then
			warn("Already got ", weaponInstance:GetFullName())
			warn(debug.traceback())
			return
		end

		-- We should be pretty sure we got a valid weaponType by now
		assert(weaponType, "Got invalid weaponType")

		local weapon = weaponType.new(WeaponsSystem, weaponInstance)
		WeaponsSystem.knownWeapons[weaponInstance] = weapon
	end)()
end

function WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not typeof(weaponInstance) == "Instance" then
		warn("WeaponsSystem.getWeaponForInstance(weaponInstance): 'weaponInstance' was not an instance.")
		return nil
	end

	return WeaponsSystem.knownWeapons[weaponInstance]
end

-- and (IsServer or weaponInstance:IsDescendantOf(Players.LocalPlayer))

function WeaponsSystem.onWeaponAdded(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not weapon then
		WeaponsSystem.createWeaponForInstance(weaponInstance)
	end
end

function WeaponsSystem.onWeaponRemoved(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if weapon then
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons[weaponInstance] = nil
end

function WeaponsSystem.getRemoteEvent(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteEvent = WeaponsSystem.remoteEvents[name]
	if IsServer then
		if not remoteEvent then
			warn("No RemoteEvent named ", name)
			return nil
		end

		return remoteEvent
	else
		if not remoteEvent then
			remoteEvent = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteEvent
	end
end

function WeaponsSystem.getRemoteFunction(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteFunc = WeaponsSystem.remoteFunctions[name]
	if IsServer then
		if not remoteFunc then
			warn("No RemoteFunction named ", name)
			return nil
		end

		return remoteFunc
	else
		if not remoteFunc then
			remoteFunc = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteFunc
	end
end

function WeaponsSystem.setWeaponEquipped(weapon, equipped)
	assert(not IsServer, "WeaponsSystem.setWeaponEquipped should only be called on the client.")
	if not weapon then
		return
	end

	local lastWeapon = WeaponsSystem.currentWeapon
	local hasWeapon = false
	local weaponChanged = false

	if lastWeapon == weapon then
		if not equipped then
			WeaponsSystem.currentWeapon = nil
			hasWeapon = false
			weaponChanged = true
		else
			weaponChanged = false
		end
	else
		if equipped then
			WeaponsSystem.currentWeapon = weapon
			hasWeapon = true
			weaponChanged = true
		end
	end

	if WeaponsSystem.camera then
		WeaponsSystem.camera:resetZoomFactor()
		WeaponsSystem.camera:setHasScope(false)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.camera:setZoomFactor(WeaponsSystem.currentWeapon:getConfigValue("ZoomFactor", 1.1))
			WeaponsSystem.camera:setHasScope(WeaponsSystem.currentWeapon:getConfigValue("HasScope", false))
		end
	end

	if WeaponsSystem.gui then
		WeaponsSystem.gui:setEnabled(hasWeapon)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.gui:setCrosshairWeaponScale(WeaponsSystem.currentWeapon:getConfigValue("CrosshairScale", 1))
		else
			WeaponsSystem.gui:setCrosshairWeaponScale(1)
		end
	end

	if weaponChanged then
		WeaponsSystem.CurrentWeaponChanged:Fire(weapon.instance, lastWeapon and lastWeapon.instance)
	end
end

function WeaponsSystem.getHumanoid(part)
	while part and part ~= workspace do
		if part:IsA("Model") and part.PrimaryPart and part.PrimaryPart.Name == "HumanoidRootPart" then
			return part:FindFirstChildOfClass("Humanoid")
		end

		part = part.Parent
	end
end

function WeaponsSystem.getPlayerFromHumanoid(humanoid)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and humanoid:IsDescendantOf(player.Character) then
			return player
		end
	end
end

local function _defaultDamageCallback(system, target, amount, damageType, dealer, hitInfo, damageData)
	if target:IsA("Humanoid") then
		target:TakeDamage(amount)
	end
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function WeaponsSystem.doDamage(target, amount, damageType, dealer, hitInfo, damageData)
	if not target or ancestorHasTag(target, "WeaponsSystemIgnore") then
		return
	end
	if IsServer then
		if target:IsA("Humanoid") and dealer:IsA("Player") and dealer.Character then
			local dealerHumanoid = dealer.Character:FindFirstChildOfClass("Humanoid")
			local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
			if dealerHumanoid and target ~= dealerHumanoid and targetPlayer then
				-- Trigger the damage indicator
				WeaponData:FireClient(targetPlayer, "HitByOtherPlayer", dealer.Character.HumanoidRootPart.CFrame.Position)
			end
		end

		-- NOTE:  damageData is a more or less free-form parameter that can be used for passing information from the code that is dealing damage about the cause.
		-- .The most obvious usage is extracting icons from the various weapon types (in which case a weapon instance would likely be passed in)
		-- ..The default weapons pass in that data
		UntagHumanoid(target)
		TagHumanoid(target, dealer)
		local handler = _damageCallback or _defaultDamageCallback
		handler(WeaponsSystem, target, amount, damageType, dealer, hitInfo, damageData)
	end
end

local function _defaultGetTeamCallback(player)
	return 0
end

function WeaponsSystem.getTeam(player)
	local handler = _getTeamCallback or _defaultGetTeamCallback
	return handler(player)
end

function WeaponsSystem.playersOnDifferentTeams(player1, player2)
	if player1 == player2 or player1 == nil or player2 == nil then
		-- This allows players to damage themselves and NPC's
		return true
	end

	local player1Team = WeaponsSystem.getTeam(player1)
	local player2Team = WeaponsSystem.getTeam(player2)
	return player1Team == 0 or player1Team ~= player2Team
end

return WeaponsSystem
]]></string>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="LocalScript" referent="149">
      <Properties>
        <string name="Name">ClientWeaponsScript</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <bool name="Disabled">false</bool>
        <Content name="LinkedSource">
          <null>
          </null>
        </Content>
        <BinaryString name="ScriptGuid"><![CDATA[ezJBQTI2RTQwLUQ4QzktNEVGOC04OUMyLTVCOEE0NDA0QjVEMn0=]]></BinaryString>
        <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")

local playerChildAddedConnection
local replicatedStorageChildAddedConnection
local clientWeaponsScript
local weaponsSystemFolder

local function setupWeaponsSystem()
	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
end

local function onReplicatedStorageChildAdded(child)
	if child.Name == "WeaponsSystem" then
		setupWeaponsSystem()
		replicatedStorageChildAddedConnection:Disconnect()
	end
end

local function onPlayerChildAdded(child)
	if child.Name == "PlayerScripts" then
		clientWeaponsScript.Parent = child
		playerChildAddedConnection:Disconnect()
	end
end

if script.Parent.Name ~= "PlayerScripts" then
	clientWeaponsScript = script:Clone()
	local PlayerScripts = script.Parent.Parent:FindFirstChild("PlayerScripts")
	
	if PlayerScripts ~= nil then
		clientWeaponsScript.Parent = PlayerScripts
	else
		playerChildAddedConnection = script.Parent.Parent.ChildAdded:Connect(onPlayerChildAdded)
	end
else
	weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
	if weaponsSystemFolder ~= nil then
		setupWeaponsSystem()
	else
		replicatedStorageChildAddedConnection = ReplicatedStorage.ChildAdded:Connect(onReplicatedStorageChildAdded)
	end
end</string>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
  <SharedStrings>
    <SharedString md5="jMO+3ujG8WZbCV+FbCLE5Q==">Q1NHUEhTAAAAAEJMT0NL</SharedString>
  </SharedStrings>
</roblox>